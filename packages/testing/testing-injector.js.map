{"version":3,"file":"testing-injector.js","sourceRoot":"","sources":["testing-injector.ts"],"names":[],"mappings":";;;AACA,+DAAiE;AACjE,6DAGwC;AACxC,6EAAyE;AAIzE;;GAEG;AACH,MAAa,eAAgB,SAAQ,mBAAQ;IAIpC,SAAS,CAAC,MAAmB;QAClC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,YAAY,CAAC,SAAwB;QAC1C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAEM,KAAK,CAAC,wBAAwB,CACnC,SAAiB,EACjB,IAAS,EACT,iBAA4C,EAC5C,OAA2B,EAC3B,SAAS,GAAG,0BAAc,EAC1B,QAA0B,EAC1B,UAA4B;QAE5B,IAAI;YACF,MAAM,uBAAuB,GAAG,MAAM,KAAK,CAAC,wBAAwB,CAClE,SAAS,EACT,IAAI,EACJ,iBAAiB,EACjB,OAAO,EACP,SAAS,EACT,QAAQ,EACR,UAAU,CACX,CAAC;YACF,OAAO,uBAAuB,CAAC;SAChC;QAAC,OAAO,GAAG,EAAE;YACZ,IAAI,IAAI,CAAC,MAAM,EAAE;gBACf,MAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACzC,IAAI,CAAC,cAAc,EAAE;oBACnB,MAAM,GAAG,CAAC;iBACX;gBACD,MAAM,UAAU,GAAG,IAAI,kCAAe,CAAC;oBACrC,IAAI;oBACJ,OAAO,EAAE,KAAK;oBACd,KAAK,EAAE,OAAO,CAAC,KAAK;oBACpB,QAAQ,EAAE,cAAc;oBACxB,UAAU,EAAE,IAAI;oBAChB,IAAI,EAAE,SAAS;oBACf,QAAQ,EAAE,OAAO,CAAC,QAAQ;iBAC3B,CAAC,CAAC;gBACH,MAAM,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC;gBACrE,kBAAkB,CAAC,iBAAiB,CAClC;oBACE,OAAO,EAAE,IAAI;oBACb,QAAQ,EAAE,cAAc;iBACzB,EACD,kBAAkB,CAAC,SAAS,CAC7B,CAAC;gBACF,kBAAkB,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;gBAC7C,OAAO,UAAU,CAAC;aACnB;iBAAM;gBACL,MAAM,GAAG,CAAC;aACX;SACF;IACH,CAAC;CACF;AA9DD,0CA8DC","sourcesContent":["import { NestContainer } from '@nestjs/core';\r\nimport { STATIC_CONTEXT } from '@nestjs/core/injector/constants';\r\nimport {\r\n  Injector,\r\n  InjectorDependencyContext,\r\n} from '@nestjs/core/injector/injector';\r\nimport { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';\r\nimport { Module } from '@nestjs/core/injector/module';\r\nimport { MockFactory } from './interfaces';\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport class TestingInjector extends Injector {\r\n  protected mocker?: MockFactory;\r\n  protected container: NestContainer;\r\n\r\n  public setMocker(mocker: MockFactory) {\r\n    this.mocker = mocker;\r\n  }\r\n\r\n  public setContainer(container: NestContainer) {\r\n    this.container = container;\r\n  }\r\n\r\n  public async resolveComponentInstance<T>(\r\n    moduleRef: Module,\r\n    name: any,\r\n    dependencyContext: InjectorDependencyContext,\r\n    wrapper: InstanceWrapper<T>,\r\n    contextId = STATIC_CONTEXT,\r\n    inquirer?: InstanceWrapper,\r\n    keyOrIndex?: string | number,\r\n  ): Promise<InstanceWrapper> {\r\n    try {\r\n      const existingProviderWrapper = await super.resolveComponentInstance(\r\n        moduleRef,\r\n        name,\r\n        dependencyContext,\r\n        wrapper,\r\n        contextId,\r\n        inquirer,\r\n        keyOrIndex,\r\n      );\r\n      return existingProviderWrapper;\r\n    } catch (err) {\r\n      if (this.mocker) {\r\n        const mockedInstance = this.mocker(name);\r\n        if (!mockedInstance) {\r\n          throw err;\r\n        }\r\n        const newWrapper = new InstanceWrapper({\r\n          name,\r\n          isAlias: false,\r\n          scope: wrapper.scope,\r\n          instance: mockedInstance,\r\n          isResolved: true,\r\n          host: moduleRef,\r\n          metatype: wrapper.metatype,\r\n        });\r\n        const internalCoreModule = this.container.getInternalCoreModuleRef();\r\n        internalCoreModule.addCustomProvider(\r\n          {\r\n            provide: name,\r\n            useValue: mockedInstance,\r\n          },\r\n          internalCoreModule.providers,\r\n        );\r\n        internalCoreModule.addExportedProvider(name);\r\n        return newWrapper;\r\n      } else {\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}