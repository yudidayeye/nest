{"version":3,"file":"server.js","sourceRoot":"","sources":["server.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger, LoggerService } from '@nestjs/common/services/logger.service';\r\nimport { loadPackage } from '@nestjs/common/utils/load-package.util';\r\nimport {\r\n  connectable,\r\n  EMPTY,\r\n  from as fromPromise,\r\n  isObservable,\r\n  Observable,\r\n  ObservedValueOf,\r\n  of,\r\n  Subject,\r\n  Subscription,\r\n} from 'rxjs';\r\nimport { catchError, finalize, mergeMap } from 'rxjs/operators';\r\nimport { NO_EVENT_HANDLER } from '../constants';\r\nimport { BaseRpcContext } from '../ctx-host/base-rpc.context';\r\nimport { IncomingRequestDeserializer } from '../deserializers/incoming-request.deserializer';\r\nimport {\r\n  ClientOptions,\r\n  KafkaOptions,\r\n  MessageHandler,\r\n  MicroserviceOptions,\r\n  MqttOptions,\r\n  MsPattern,\r\n  NatsOptions,\r\n  ReadPacket,\r\n  RedisOptions,\r\n  RmqOptions,\r\n  TcpOptions,\r\n  WritePacket,\r\n} from '../interfaces';\r\nimport { ConsumerDeserializer } from '../interfaces/deserializer.interface';\r\nimport { ConsumerSerializer } from '../interfaces/serializer.interface';\r\nimport { IdentitySerializer } from '../serializers/identity.serializer';\r\nimport { transformPatternToRoute } from '../utils';\r\n\r\nexport abstract class Server {\r\n  protected readonly messageHandlers = new Map<string, MessageHandler>();\r\n  protected readonly logger: LoggerService = new Logger(Server.name);\r\n  protected serializer: ConsumerSerializer;\r\n  protected deserializer: ConsumerDeserializer;\r\n\r\n  public addHandler(\r\n    pattern: any,\r\n    callback: MessageHandler,\r\n    isEventHandler = false,\r\n    extras: Record<string, any> = {},\r\n  ) {\r\n    const normalizedPattern = this.normalizePattern(pattern);\r\n    callback.isEventHandler = isEventHandler;\r\n    callback.extras = extras;\r\n\r\n    if (this.messageHandlers.has(normalizedPattern) && isEventHandler) {\r\n      const headRef = this.messageHandlers.get(normalizedPattern);\r\n      const getTail = (handler: MessageHandler) =>\r\n        handler?.next ? getTail(handler.next) : handler;\r\n\r\n      const tailRef = getTail(headRef);\r\n      tailRef.next = callback;\r\n    } else {\r\n      this.messageHandlers.set(normalizedPattern, callback);\r\n    }\r\n  }\r\n\r\n  public getHandlers(): Map<string, MessageHandler> {\r\n    return this.messageHandlers;\r\n  }\r\n\r\n  public getHandlerByPattern(pattern: string): MessageHandler | null {\r\n    const route = this.getRouteFromPattern(pattern);\r\n    return this.messageHandlers.has(route)\r\n      ? this.messageHandlers.get(route)\r\n      : null;\r\n  }\r\n\r\n  public send(\r\n    stream$: Observable<any>,\r\n    respond: (data: WritePacket) => unknown | Promise<unknown>,\r\n  ): Subscription {\r\n    let dataBuffer: WritePacket[] = null;\r\n    const scheduleOnNextTick = (data: WritePacket) => {\r\n      if (!dataBuffer) {\r\n        dataBuffer = [data];\r\n        process.nextTick(async () => {\r\n          for (const item of dataBuffer) {\r\n            await respond(item);\r\n          }\r\n          dataBuffer = null;\r\n        });\r\n      } else if (!data.isDisposed) {\r\n        dataBuffer = dataBuffer.concat(data);\r\n      } else {\r\n        dataBuffer[dataBuffer.length - 1].isDisposed = data.isDisposed;\r\n      }\r\n    };\r\n    return stream$\r\n      .pipe(\r\n        catchError((err: any) => {\r\n          scheduleOnNextTick({ err });\r\n          return EMPTY;\r\n        }),\r\n        finalize(() => scheduleOnNextTick({ isDisposed: true })),\r\n      )\r\n      .subscribe((response: any) => scheduleOnNextTick({ response }));\r\n  }\r\n\r\n  public async handleEvent(\r\n    pattern: string,\r\n    packet: ReadPacket,\r\n    context: BaseRpcContext,\r\n  ): Promise<any> {\r\n    const handler = this.getHandlerByPattern(pattern);\r\n    if (!handler) {\r\n      return this.logger.error(NO_EVENT_HANDLER`${pattern}`);\r\n    }\r\n    const resultOrStream = await handler(packet.data, context);\r\n    if (isObservable(resultOrStream)) {\r\n      const connectableSource = connectable(resultOrStream, {\r\n        connector: () => new Subject(),\r\n        resetOnDisconnect: false,\r\n      });\r\n      connectableSource.connect();\r\n    }\r\n  }\r\n\r\n  public transformToObservable<T>(\r\n    resultOrDeferred: Observable<T> | Promise<T>,\r\n  ): Observable<T>;\r\n  public transformToObservable<T>(\r\n    resultOrDeferred: T,\r\n  ): never extends Observable<ObservedValueOf<T>>\r\n    ? Observable<T>\r\n    : Observable<ObservedValueOf<T>>;\r\n  public transformToObservable(resultOrDeferred: any) {\r\n    if (resultOrDeferred instanceof Promise) {\r\n      return fromPromise(resultOrDeferred).pipe(\r\n        mergeMap(val => (isObservable(val) ? val : of(val))),\r\n      );\r\n    }\r\n\r\n    if (isObservable(resultOrDeferred)) {\r\n      return resultOrDeferred;\r\n    }\r\n\r\n    return of(resultOrDeferred);\r\n  }\r\n\r\n  public getOptionsProp<\r\n    T extends MicroserviceOptions['options'],\r\n    K extends keyof T,\r\n  >(obj: T, prop: K, defaultValue: T[K] = undefined) {\r\n    return obj && prop in obj ? obj[prop] : defaultValue;\r\n  }\r\n\r\n  protected handleError(error: string) {\r\n    this.logger.error(error);\r\n  }\r\n\r\n  protected loadPackage<T = any>(\r\n    name: string,\r\n    ctx: string,\r\n    loader?: Function,\r\n  ): T {\r\n    return loadPackage(name, ctx, loader);\r\n  }\r\n\r\n  protected initializeSerializer(options: ClientOptions['options']) {\r\n    this.serializer =\r\n      (options &&\r\n        (\r\n          options as\r\n            | RedisOptions['options']\r\n            | NatsOptions['options']\r\n            | MqttOptions['options']\r\n            | TcpOptions['options']\r\n            | RmqOptions['options']\r\n            | KafkaOptions['options']\r\n        ).serializer) ||\r\n      new IdentitySerializer();\r\n  }\r\n\r\n  protected initializeDeserializer(options: ClientOptions['options']) {\r\n    this.deserializer =\r\n      (options &&\r\n        (\r\n          options as\r\n            | RedisOptions['options']\r\n            | NatsOptions['options']\r\n            | MqttOptions['options']\r\n            | TcpOptions['options']\r\n            | RmqOptions['options']\r\n            | KafkaOptions['options']\r\n        ).deserializer) ||\r\n      new IncomingRequestDeserializer();\r\n  }\r\n\r\n  /**\r\n   * Transforms the server Pattern to valid type and returns a route for him.\r\n   *\r\n   * @param  {string} pattern - server pattern\r\n   * @returns string\r\n   */\r\n  protected getRouteFromPattern(pattern: string): string {\r\n    let validPattern: MsPattern;\r\n\r\n    try {\r\n      validPattern = JSON.parse(pattern);\r\n    } catch (error) {\r\n      // Uses a fundamental object (`pattern` variable without any conversion)\r\n      validPattern = pattern;\r\n    }\r\n    return this.normalizePattern(validPattern);\r\n  }\r\n\r\n  protected normalizePattern(pattern: MsPattern): string {\r\n    return transformPatternToRoute(pattern);\r\n  }\r\n}\r\n"]}