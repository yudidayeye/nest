{"version":3,"file":"kafka-reply-partition-assigner.js","sourceRoot":"","sources":["kafka-reply-partition-assigner.ts"],"names":[],"mappings":"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","sourcesContent":["import { loadPackage } from '@nestjs/common/utils/load-package.util';\r\nimport { isUndefined } from '@nestjs/common/utils/shared.utils';\r\nimport { ClientKafka } from '../client/client-kafka';\r\nimport {\r\n  Cluster,\r\n  GroupMember,\r\n  GroupMemberAssignment,\r\n  GroupState,\r\n  MemberMetadata,\r\n} from '../external/kafka.interface';\r\n\r\nlet kafkaPackage: any = {};\r\n\r\nexport class KafkaReplyPartitionAssigner {\r\n  readonly name = 'NestReplyPartitionAssigner';\r\n  readonly version = 1;\r\n\r\n  constructor(\r\n    private readonly clientKafka: ClientKafka,\r\n    private readonly config: {\r\n      cluster: Cluster;\r\n    },\r\n  ) {\r\n    kafkaPackage = loadPackage(\r\n      'kafkajs',\r\n      KafkaReplyPartitionAssigner.name,\r\n      () => require('kafkajs'),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * This process can result in imbalanced assignments\r\n   * @param {array} members array of members, e.g: [{ memberId: 'test-5f93f5a3' }]\r\n   * @param {array} topics\r\n   * @param {Buffer} userData\r\n   * @returns {array} object partitions per topic per member\r\n   */\r\n  public async assign(group: {\r\n    members: GroupMember[];\r\n    topics: string[];\r\n  }): Promise<GroupMemberAssignment[]> {\r\n    const assignment = {};\r\n    const previousAssignment = {};\r\n\r\n    const membersCount = group.members.length;\r\n    const decodedMembers = group.members.map(member =>\r\n      this.decodeMember(member),\r\n    );\r\n    const sortedMemberIds = decodedMembers\r\n      .map(member => member.memberId)\r\n      .sort();\r\n\r\n    // build the previous assignment and an inverse map of topic > partition > memberId for lookup\r\n    decodedMembers.forEach(member => {\r\n      if (\r\n        !previousAssignment[member.memberId] &&\r\n        Object.keys(member.previousAssignment).length > 0\r\n      ) {\r\n        previousAssignment[member.memberId] = member.previousAssignment;\r\n      }\r\n    });\r\n\r\n    // build a collection of topics and partitions\r\n    const topicsPartitions = group.topics\r\n      .map(topic => {\r\n        const partitionMetadata =\r\n          this.config.cluster.findTopicPartitionMetadata(topic);\r\n        return partitionMetadata.map(m => {\r\n          return {\r\n            topic,\r\n            partitionId: m.partitionId,\r\n          };\r\n        });\r\n      })\r\n      .reduce((acc, val) => acc.concat(val), []);\r\n\r\n    // create the new assignment by populating the members with the first partition of the topics\r\n    sortedMemberIds.forEach(assignee => {\r\n      if (!assignment[assignee]) {\r\n        assignment[assignee] = {};\r\n      }\r\n\r\n      // add topics to each member\r\n      group.topics.forEach(topic => {\r\n        if (!assignment[assignee][topic]) {\r\n          assignment[assignee][topic] = [];\r\n        }\r\n\r\n        // see if the topic and partition belong to a previous assignment\r\n        if (\r\n          previousAssignment[assignee] &&\r\n          !isUndefined(previousAssignment[assignee][topic])\r\n        ) {\r\n          // take the minimum partition since replies will be sent to the minimum partition\r\n          const firstPartition = previousAssignment[assignee][topic];\r\n\r\n          // create the assignment with the first partition\r\n          assignment[assignee][topic].push(firstPartition);\r\n\r\n          // find and remove this topic and partition from the topicPartitions to be assigned later\r\n          const topicsPartitionsIndex = topicsPartitions.findIndex(\r\n            topicPartition => {\r\n              return (\r\n                topicPartition.topic === topic &&\r\n                topicPartition.partitionId === firstPartition\r\n              );\r\n            },\r\n          );\r\n\r\n          // only continue if we found a partition matching this topic\r\n          if (topicsPartitionsIndex !== -1) {\r\n            // remove inline\r\n            topicsPartitions.splice(topicsPartitionsIndex, 1);\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // check for member topics that have a partition length of 0\r\n    sortedMemberIds.forEach(assignee => {\r\n      group.topics.forEach(topic => {\r\n        // only continue if there are no partitions for assignee's topic\r\n        if (assignment[assignee][topic].length === 0) {\r\n          // find the first partition for this topic\r\n          const topicsPartitionsIndex = topicsPartitions.findIndex(\r\n            topicPartition => {\r\n              return topicPartition.topic === topic;\r\n            },\r\n          );\r\n\r\n          if (topicsPartitionsIndex !== -1) {\r\n            // find and set the topic partition\r\n            const partition =\r\n              topicsPartitions[topicsPartitionsIndex].partitionId;\r\n\r\n            assignment[assignee][topic].push(partition);\r\n\r\n            // remove this partition from the topics partitions collection\r\n            topicsPartitions.splice(topicsPartitionsIndex, 1);\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // then balance out the rest of the topic partitions across the members\r\n    const insertAssignmentsByTopic = (topicPartition, i) => {\r\n      const assignee = sortedMemberIds[i % membersCount];\r\n\r\n      assignment[assignee][topicPartition.topic].push(\r\n        topicPartition.partitionId,\r\n      );\r\n    };\r\n\r\n    // build the assignments\r\n    topicsPartitions.forEach(insertAssignmentsByTopic);\r\n\r\n    // encode the end result\r\n    return Object.keys(assignment).map(memberId => ({\r\n      memberId,\r\n      memberAssignment: kafkaPackage.AssignerProtocol.MemberAssignment.encode({\r\n        version: this.version,\r\n        assignment: assignment[memberId],\r\n      }),\r\n    }));\r\n  }\r\n\r\n  public protocol(subscription: {\r\n    topics: string[];\r\n    userData: Buffer;\r\n  }): GroupState {\r\n    const stringifiedUserData = JSON.stringify({\r\n      previousAssignment: this.getPreviousAssignment(),\r\n    });\r\n    subscription.userData = Buffer.from(stringifiedUserData);\r\n\r\n    return {\r\n      name: this.name,\r\n      metadata: kafkaPackage.AssignerProtocol.MemberMetadata.encode({\r\n        version: this.version,\r\n        topics: subscription.topics,\r\n        userData: subscription.userData,\r\n      }),\r\n    };\r\n  }\r\n\r\n  public getPreviousAssignment() {\r\n    return this.clientKafka.getConsumerAssignments();\r\n  }\r\n\r\n  public decodeMember(member: GroupMember) {\r\n    const memberMetadata = kafkaPackage.AssignerProtocol.MemberMetadata.decode(\r\n      member.memberMetadata,\r\n    ) as MemberMetadata;\r\n    const memberUserData = JSON.parse(memberMetadata.userData.toString());\r\n\r\n    return {\r\n      memberId: member.memberId,\r\n      previousAssignment: memberUserData.previousAssignment,\r\n    };\r\n  }\r\n}\r\n"]}