{"version":3,"file":"kafka-parser.js","sourceRoot":"","sources":["kafka-parser.ts"],"names":[],"mappings":";;;AAAA,oEAA0D;AAG1D,MAAa,WAAW;IAGtB,YAAY,MAA0B;QACpC,IAAI,CAAC,UAAU,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC;IAC3D,CAAC;IAEM,KAAK,CAAU,IAAS;QAC7B,4EAA4E;QAC5E,MAAM,MAAM,GAAG;YACb,GAAG,IAAI;YACP,OAAO,EAAE,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE;SAC7B,CAAC;QAEF,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACpB,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxC;QAED,IAAI,CAAC,IAAA,oBAAK,EAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YACpB,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACpC;QACD,IAAI,CAAC,IAAA,oBAAK,EAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YACxB,MAAM,iBAAiB,GAAG,CAAC,GAAW,EAAE,EAAE;gBACxC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;YACvD,CAAC,CAAC;YACF,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;SACtD;aAAM;YACL,MAAM,CAAC,OAAO,GAAG,EAAE,CAAC;SACrB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,MAAM,CAAC,KAAa;QACzB,IAAI,IAAA,oBAAK,EAAC,KAAK,CAAC,EAAE;YAChB,OAAO,IAAI,CAAC;SACb;QACD,qEAAqE;QACrE,uEAAuE;QACvE,IACE,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC;YACtB,KAAK,CAAC,MAAM,GAAG,CAAC;YAChB,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,EACxB;YACA,OAAO,KAAK,CAAC;SACd;QAED,IAAI,MAAM,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;QAC9B,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAEnC,uCAAuC;QACvC,IAAI,SAAS,KAAK,GAAG,IAAI,SAAS,KAAK,GAAG,EAAE;YAC1C,IAAI;gBACF,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC;aACvC;YAAC,OAAO,CAAC,EAAE,GAAE;SACf;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAzDD,kCAyDC","sourcesContent":["import { isNil } from '@nestjs/common/utils/shared.utils';\r\nimport { KafkaParserConfig } from '../interfaces';\r\n\r\nexport class KafkaParser {\r\n  protected readonly keepBinary: boolean;\r\n\r\n  constructor(config?: KafkaParserConfig) {\r\n    this.keepBinary = (config && config.keepBinary) || false;\r\n  }\r\n\r\n  public parse<T = any>(data: any): T {\r\n    // Clone object to as modifying the original one would break KafkaJS retries\r\n    const result = {\r\n      ...data,\r\n      headers: { ...data.headers },\r\n    };\r\n\r\n    if (!this.keepBinary) {\r\n      result.value = this.decode(data.value);\r\n    }\r\n\r\n    if (!isNil(data.key)) {\r\n      result.key = this.decode(data.key);\r\n    }\r\n    if (!isNil(data.headers)) {\r\n      const decodeHeaderByKey = (key: string) => {\r\n        result.headers[key] = this.decode(data.headers[key]);\r\n      };\r\n      Object.keys(data.headers).forEach(decodeHeaderByKey);\r\n    } else {\r\n      result.headers = {};\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public decode(value: Buffer): object | string | null | Buffer {\r\n    if (isNil(value)) {\r\n      return null;\r\n    }\r\n    // A value with the \"leading zero byte\" indicates the schema payload.\r\n    // The \"content\" is possibly binary and should not be touched & parsed.\r\n    if (\r\n      Buffer.isBuffer(value) &&\r\n      value.length > 0 &&\r\n      value.readUInt8(0) === 0\r\n    ) {\r\n      return value;\r\n    }\r\n\r\n    let result = value.toString();\r\n    const startChar = result.charAt(0);\r\n\r\n    // only try to parse objects and arrays\r\n    if (startChar === '{' || startChar === '[') {\r\n      try {\r\n        result = JSON.parse(value.toString());\r\n      } catch (e) {}\r\n    }\r\n    return result;\r\n  }\r\n}\r\n"]}