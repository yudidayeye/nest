{"version":3,"file":"client-tcp.js","sourceRoot":"","sources":["client-tcp.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger, Type } from '@nestjs/common';\r\nimport * as net from 'net';\r\nimport { EmptyError, lastValueFrom } from 'rxjs';\r\nimport { share, tap } from 'rxjs/operators';\r\nimport { ConnectionOptions } from 'tls';\r\nimport {\r\n  CLOSE_EVENT,\r\n  ECONNREFUSED,\r\n  ERROR_EVENT,\r\n  MESSAGE_EVENT,\r\n  TCP_DEFAULT_HOST,\r\n  TCP_DEFAULT_PORT,\r\n} from '../constants';\r\nimport { JsonSocket, TcpSocket } from '../helpers';\r\nimport { connect as tlsConnect, TLSSocket } from 'tls';\r\nimport { PacketId, ReadPacket, WritePacket } from '../interfaces';\r\nimport { TcpClientOptions } from '../interfaces/client-metadata.interface';\r\nimport { ClientProxy } from './client-proxy';\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport class ClientTCP extends ClientProxy {\r\n  protected connection: Promise<any>;\r\n  private readonly logger = new Logger(ClientTCP.name);\r\n  private readonly port: number;\r\n  private readonly host: string;\r\n  private readonly socketClass: Type<TcpSocket>;\r\n  private isConnected = false;\r\n  private socket: TcpSocket;\r\n  public tlsOptions?: ConnectionOptions;\r\n\r\n  constructor(options: TcpClientOptions['options']) {\r\n    super();\r\n    this.port = this.getOptionsProp(options, 'port') || TCP_DEFAULT_PORT;\r\n    this.host = this.getOptionsProp(options, 'host') || TCP_DEFAULT_HOST;\r\n    this.socketClass =\r\n      this.getOptionsProp(options, 'socketClass') || JsonSocket;\r\n    this.tlsOptions = this.getOptionsProp(options, 'tlsOptions');\r\n\r\n    this.initializeSerializer(options);\r\n    this.initializeDeserializer(options);\r\n  }\r\n\r\n  public connect(): Promise<any> {\r\n    if (this.connection) {\r\n      return this.connection;\r\n    }\r\n    this.socket = this.createSocket();\r\n    this.bindEvents(this.socket);\r\n\r\n    const source$ = this.connect$(this.socket.netSocket).pipe(\r\n      tap(() => {\r\n        this.isConnected = true;\r\n        this.socket.on(MESSAGE_EVENT, (buffer: WritePacket & PacketId) =>\r\n          this.handleResponse(buffer),\r\n        );\r\n      }),\r\n      share(),\r\n    );\r\n\r\n    // For TLS connections, the connection is initiated when the socket is created\r\n    if (!this.tlsOptions) {\r\n      this.socket.connect(this.port, this.host);\r\n    }\r\n    this.connection = lastValueFrom(source$).catch(err => {\r\n      if (err instanceof EmptyError) {\r\n        return;\r\n      }\r\n      throw err;\r\n    });\r\n\r\n    return this.connection;\r\n  }\r\n\r\n  public async handleResponse(buffer: unknown): Promise<void> {\r\n    const { err, response, isDisposed, id } =\r\n      await this.deserializer.deserialize(buffer);\r\n    const callback = this.routingMap.get(id);\r\n    if (!callback) {\r\n      return undefined;\r\n    }\r\n    if (isDisposed || err) {\r\n      return callback({\r\n        err,\r\n        response,\r\n        isDisposed: true,\r\n      });\r\n    }\r\n    callback({\r\n      err,\r\n      response,\r\n    });\r\n  }\r\n\r\n  public createSocket(): TcpSocket {\r\n    let socket: net.Socket | TLSSocket;\r\n    /**\r\n     * TLS enabled, \"upgrade\" the TCP Socket to TLS\r\n     */\r\n    if (this.tlsOptions) {\r\n      socket = tlsConnect({\r\n        ...this.tlsOptions,\r\n        port: this.port,\r\n        host: this.host,\r\n        socket,\r\n      });\r\n    } else {\r\n      socket = new net.Socket();\r\n    }\r\n    return new this.socketClass(socket);\r\n  }\r\n\r\n  public close() {\r\n    this.socket && this.socket.end();\r\n    this.handleClose();\r\n  }\r\n\r\n  public bindEvents(socket: TcpSocket) {\r\n    socket.on(\r\n      ERROR_EVENT,\r\n      (err: any) => err.code !== ECONNREFUSED && this.handleError(err),\r\n    );\r\n    socket.on(CLOSE_EVENT, () => this.handleClose());\r\n  }\r\n\r\n  public handleError(err: any) {\r\n    this.logger.error(err);\r\n  }\r\n\r\n  public handleClose() {\r\n    this.isConnected = false;\r\n    this.socket = null;\r\n    this.connection = undefined;\r\n\r\n    if (this.routingMap.size > 0) {\r\n      const err = new Error('Connection closed');\r\n      for (const callback of this.routingMap.values()) {\r\n        callback({ err });\r\n      }\r\n      this.routingMap.clear();\r\n    }\r\n  }\r\n\r\n  protected publish(\r\n    partialPacket: ReadPacket,\r\n    callback: (packet: WritePacket) => any,\r\n  ): () => void {\r\n    try {\r\n      const packet = this.assignPacketId(partialPacket);\r\n      const serializedPacket = this.serializer.serialize(packet);\r\n\r\n      this.routingMap.set(packet.id, callback);\r\n      this.socket.sendMessage(serializedPacket);\r\n\r\n      return () => this.routingMap.delete(packet.id);\r\n    } catch (err) {\r\n      callback({ err });\r\n    }\r\n  }\r\n\r\n  protected async dispatchEvent(packet: ReadPacket): Promise<any> {\r\n    const pattern = this.normalizePattern(packet.pattern);\r\n    const serializedPacket = this.serializer.serialize({\r\n      ...packet,\r\n      pattern,\r\n    });\r\n    return this.socket.sendMessage(serializedPacket);\r\n  }\r\n}\r\n"]}