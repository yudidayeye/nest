{"version":3,"file":"kafka.interface.js","sourceRoot":"","sources":["kafka.interface.ts"],"names":[],"mappings":";AAAA;;;;;;;GAOG;;;AAiRH,IAAY,gBAQX;AARD,WAAY,gBAAgB;IAC1B,6DAAW,CAAA;IACX,qDAAO,CAAA;IACP,yDAAS,CAAA;IACT,yDAAS,CAAA;IACT,6DAAW,CAAA;IACX,+EAAoB,CAAA;IACpB,+EAAoB,CAAA;AACtB,CAAC,EARW,gBAAgB,gCAAhB,gBAAgB,QAQ3B;AAED,IAAY,mBAKX;AALD,WAAY,mBAAmB;IAC7B,mEAAW,CAAA;IACX,+DAAS,CAAA;IACT,iEAAU,CAAA;IACV,+EAAiB,CAAA;AACnB,CAAC,EALW,mBAAmB,mCAAnB,mBAAmB,QAK9B;AAED,IAAY,YAQX;AARD,WAAY,YAAY;IACtB,qDAAW,CAAA;IACX,+DAAgB,CAAA;IAChB,iFAAyB,CAAA;IACzB,iGAAiC,CAAA;IACjC,+EAAwB,CAAA;IACxB,mEAAkB,CAAA;IAClB,+FAAgC,CAAA;AAClC,CAAC,EARW,YAAY,4BAAZ,YAAY,QAQvB;AAED,IAAY,kBAKX;AALD,WAAY,kBAAkB;IAC5B,iEAAW,CAAA;IACX,yDAAO,CAAA;IACP,2DAAQ,CAAA;IACR,6DAAS,CAAA;AACX,CAAC,EALW,kBAAkB,kCAAlB,kBAAkB,QAK7B;AAED,IAAY,iBAcX;AAdD,WAAY,iBAAiB;IAC3B,+DAAW,CAAA;IACX,uDAAO,CAAA;IACP,uDAAO,CAAA;IACP,yDAAQ,CAAA;IACR,2DAAS,CAAA;IACT,6DAAU,CAAA;IACV,6DAAU,CAAA;IACV,2DAAS,CAAA;IACT,iEAAY,CAAA;IACZ,6EAAkB,CAAA;IAClB,kFAAqB,CAAA;IACrB,4EAAkB,CAAA;IAClB,kFAAqB,CAAA;AACvB,CAAC,EAdW,iBAAiB,iCAAjB,iBAAiB,QAc5B;AAED,IAAY,oBAMX;AAND,WAAY,oBAAoB;IAC9B,qEAAW,CAAA;IACX,6DAAO,CAAA;IACP,iEAAS,CAAA;IACT,qEAAW,CAAA;IACX,uEAAY,CAAA;AACd,CAAC,EANW,oBAAoB,oCAApB,oBAAoB,QAM/B;AAqRD,IAAY,QAMX;AAND,WAAY,QAAQ;IAClB,6CAAW,CAAA;IACX,yCAAS,CAAA;IACT,uCAAQ,CAAA;IACR,uCAAQ,CAAA;IACR,yCAAS,CAAA;AACX,CAAC,EANW,QAAQ,wBAAR,QAAQ,QAMnB;AAkgBD,IAAY,gBAMX;AAND,WAAY,gBAAgB;IAC1B,uDAAQ,CAAA;IACR,uDAAQ,CAAA;IACR,2DAAU,CAAA;IACV,qDAAO,CAAA;IACP,uDAAQ,CAAA;AACV,CAAC,EANW,gBAAgB,gCAAhB,gBAAgB,QAM3B","sourcesContent":["/**\r\n * Do NOT add NestJS logic to this interface.  It is meant to ONLY represent the types for the kafkajs package.\r\n *\r\n * @see https://github.com/tulios/kafkajs/blob/master/types/index.d.ts\r\n *\r\n * @publicApi\r\n *\r\n */\r\n\r\n/// <reference types=\"node\" />\r\nimport * as net from 'net';\r\nimport * as tls from 'tls';\r\n\r\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\r\ntype XOR<T, U> = T | U extends object\r\n  ? (Without<T, U> & U) | (Without<U, T> & T)\r\n  : T | U;\r\n\r\nexport declare class Kafka {\r\n  constructor(config: KafkaConfig);\r\n  producer(config?: ProducerConfig): Producer;\r\n  consumer(config: ConsumerConfig): Consumer;\r\n  admin(config?: AdminConfig): Admin;\r\n  logger(): Logger;\r\n}\r\n\r\nexport type BrokersFunction = () => string[] | Promise<string[]>;\r\n\r\ntype SaslAuthenticationRequest = {\r\n  encode: () => Buffer | Promise<Buffer>;\r\n};\r\ntype SaslAuthenticationResponse<ParseResult> = {\r\n  decode: (rawResponse: Buffer) => Buffer | Promise<Buffer>;\r\n  parse: (data: Buffer) => ParseResult;\r\n};\r\n\r\ntype Authenticator = {\r\n  authenticate: () => Promise<void>;\r\n};\r\n\r\ntype AuthenticationProviderArgs = {\r\n  host: string;\r\n  port: number;\r\n  logger: Logger;\r\n  saslAuthenticate: <ParseResult>(\r\n    request: SaslAuthenticationRequest,\r\n    response?: SaslAuthenticationResponse<ParseResult>,\r\n  ) => Promise<ParseResult | void>;\r\n};\r\n\r\ntype Mechanism = {\r\n  mechanism: string;\r\n  authenticationProvider: (args: AuthenticationProviderArgs) => Authenticator;\r\n};\r\n\r\nexport interface KafkaConfig {\r\n  brokers: string[] | BrokersFunction;\r\n  ssl?: tls.ConnectionOptions | boolean;\r\n  sasl?: SASLOptions | Mechanism;\r\n  clientId?: string;\r\n  connectionTimeout?: number;\r\n  authenticationTimeout?: number;\r\n  reauthenticationThreshold?: number;\r\n  requestTimeout?: number;\r\n  enforceRequestTimeout?: boolean;\r\n  retry?: RetryOptions;\r\n  socketFactory?: ISocketFactory;\r\n  logLevel?: logLevel;\r\n  logCreator?: logCreator;\r\n}\r\n\r\nexport interface ISocketFactoryArgs {\r\n  host: string;\r\n  port: number;\r\n  ssl: tls.ConnectionOptions;\r\n  onConnect: () => void;\r\n}\r\n\r\nexport type ISocketFactory = (args: ISocketFactoryArgs) => net.Socket;\r\n\r\nexport interface OauthbearerProviderResponse {\r\n  value: string;\r\n}\r\n\r\ntype SASLMechanismOptionsMap = {\r\n  plain: { username: string; password: string };\r\n  'scram-sha-256': { username: string; password: string };\r\n  'scram-sha-512': { username: string; password: string };\r\n  aws: {\r\n    authorizationIdentity: string;\r\n    accessKeyId: string;\r\n    secretAccessKey: string;\r\n    sessionToken?: string;\r\n  };\r\n  oauthbearer: {\r\n    oauthBearerProvider: () => Promise<OauthbearerProviderResponse>;\r\n  };\r\n};\r\n\r\nexport type SASLMechanism = keyof SASLMechanismOptionsMap;\r\ntype SASLMechanismOptions<T> = T extends SASLMechanism\r\n  ? { mechanism: T } & SASLMechanismOptionsMap[T]\r\n  : never;\r\nexport type SASLOptions = SASLMechanismOptions<SASLMechanism>;\r\n\r\nexport interface ProducerConfig {\r\n  createPartitioner?: ICustomPartitioner;\r\n  retry?: RetryOptions;\r\n  metadataMaxAge?: number;\r\n  allowAutoTopicCreation?: boolean;\r\n  idempotent?: boolean;\r\n  transactionalId?: string;\r\n  transactionTimeout?: number;\r\n  maxInFlightRequests?: number;\r\n}\r\n\r\nexport interface Message {\r\n  key?: Buffer | string | null;\r\n  value: Buffer | string | null;\r\n  partition?: number;\r\n  headers?: IHeaders;\r\n  timestamp?: string;\r\n}\r\n\r\nexport interface PartitionerArgs {\r\n  topic: string;\r\n  partitionMetadata: PartitionMetadata[];\r\n  message: Message;\r\n}\r\n\r\nexport type ICustomPartitioner = () => (args: PartitionerArgs) => number;\r\nexport type DefaultPartitioner = ICustomPartitioner;\r\nexport type LegacyPartitioner = ICustomPartitioner;\r\n\r\nexport let Partitioners: {\r\n  DefaultPartitioner: DefaultPartitioner;\r\n  LegacyPartitioner: LegacyPartitioner;\r\n  /**\r\n   * @deprecated Use DefaultPartitioner instead\r\n   *\r\n   * The JavaCompatiblePartitioner was renamed DefaultPartitioner\r\n   * and made to be the default in 2.0.0.\r\n   */\r\n  JavaCompatiblePartitioner: DefaultPartitioner;\r\n};\r\n\r\nexport type PartitionMetadata = {\r\n  partitionErrorCode: number;\r\n  partitionId: number;\r\n  leader: number;\r\n  replicas: number[];\r\n  isr: number[];\r\n  offlineReplicas?: number[];\r\n};\r\n\r\nexport interface IHeaders {\r\n  [key: string]: Buffer | string | (Buffer | string)[] | undefined;\r\n}\r\n\r\nexport interface ConsumerConfig {\r\n  groupId: string;\r\n  partitionAssigners?: PartitionAssigner[];\r\n  metadataMaxAge?: number;\r\n  sessionTimeout?: number;\r\n  rebalanceTimeout?: number;\r\n  heartbeatInterval?: number;\r\n  maxBytesPerPartition?: number;\r\n  minBytes?: number;\r\n  maxBytes?: number;\r\n  maxWaitTimeInMs?: number;\r\n  retry?: RetryOptions & {\r\n    restartOnFailure?: (err: Error) => Promise<boolean>;\r\n  };\r\n  allowAutoTopicCreation?: boolean;\r\n  maxInFlightRequests?: number;\r\n  readUncommitted?: boolean;\r\n  rackId?: string;\r\n}\r\n\r\nexport type PartitionAssigner = (config: {\r\n  cluster: Cluster;\r\n  groupId: string;\r\n  logger: Logger;\r\n}) => Assigner;\r\n\r\nexport interface CoordinatorMetadata {\r\n  errorCode: number;\r\n  coordinator: {\r\n    nodeId: number;\r\n    host: string;\r\n    port: number;\r\n  };\r\n}\r\n\r\nexport type Cluster = {\r\n  getNodeIds(): number[];\r\n  metadata(): Promise<BrokerMetadata>;\r\n  removeBroker(options: { host: string; port: number }): void;\r\n  addMultipleTargetTopics(topics: string[]): Promise<void>;\r\n  isConnected(): boolean;\r\n  connect(): Promise<void>;\r\n  disconnect(): Promise<void>;\r\n  refreshMetadata(): Promise<void>;\r\n  refreshMetadataIfNecessary(): Promise<void>;\r\n  addTargetTopic(topic: string): Promise<void>;\r\n  findBroker(node: { nodeId: string }): Promise<Broker>;\r\n  findControllerBroker(): Promise<Broker>;\r\n  findTopicPartitionMetadata(topic: string): PartitionMetadata[];\r\n  findLeaderForPartitions(\r\n    topic: string,\r\n    partitions: number[],\r\n  ): { [leader: string]: number[] };\r\n  findGroupCoordinator(group: { groupId: string }): Promise<Broker>;\r\n  findGroupCoordinatorMetadata(group: {\r\n    groupId: string;\r\n  }): Promise<CoordinatorMetadata>;\r\n  defaultOffset(config: { fromBeginning: boolean }): number;\r\n  fetchTopicsOffset(\r\n    topics: Array<\r\n      {\r\n        topic: string;\r\n        partitions: Array<{ partition: number }>;\r\n      } & XOR<{ fromBeginning: boolean }, { fromTimestamp: number }>\r\n    >,\r\n  ): Promise<TopicOffsets[]>;\r\n};\r\n\r\nexport type Assignment = { [topic: string]: number[] };\r\n\r\nexport type GroupMember = { memberId: string; memberMetadata: Buffer };\r\n\r\nexport type GroupMemberAssignment = {\r\n  memberId: string;\r\n  memberAssignment: Buffer;\r\n};\r\n\r\nexport type GroupState = { name: string; metadata: Buffer };\r\n\r\nexport type Assigner = {\r\n  name: string;\r\n  version: number;\r\n  assign(group: {\r\n    members: GroupMember[];\r\n    topics: string[];\r\n  }): Promise<GroupMemberAssignment[]>;\r\n  protocol(subscription: { topics: string[] }): GroupState;\r\n};\r\n\r\nexport interface RetryOptions {\r\n  maxRetryTime?: number;\r\n  initialRetryTime?: number;\r\n  factor?: number;\r\n  multiplier?: number;\r\n  retries?: number;\r\n  restartOnFailure?: (e: Error) => Promise<boolean>;\r\n}\r\n\r\nexport interface AdminConfig {\r\n  retry?: RetryOptions;\r\n}\r\n\r\nexport interface ITopicConfig {\r\n  topic: string;\r\n  numPartitions?: number;\r\n  replicationFactor?: number;\r\n  replicaAssignment?: object[];\r\n  configEntries?: IResourceConfigEntry[];\r\n}\r\n\r\nexport interface ITopicPartitionConfig {\r\n  topic: string;\r\n  count: number;\r\n  assignments?: Array<Array<number>>;\r\n}\r\n\r\nexport interface ITopicMetadata {\r\n  name: string;\r\n  partitions: PartitionMetadata[];\r\n}\r\n\r\nexport enum AclResourceTypes {\r\n  UNKNOWN = 0,\r\n  ANY = 1,\r\n  TOPIC = 2,\r\n  GROUP = 3,\r\n  CLUSTER = 4,\r\n  TRANSACTIONAL_ID = 5,\r\n  DELEGATION_TOKEN = 6,\r\n}\r\n\r\nexport enum ConfigResourceTypes {\r\n  UNKNOWN = 0,\r\n  TOPIC = 2,\r\n  BROKER = 4,\r\n  BROKER_LOGGER = 8,\r\n}\r\n\r\nexport enum ConfigSource {\r\n  UNKNOWN = 0,\r\n  TOPIC_CONFIG = 1,\r\n  DYNAMIC_BROKER_CONFIG = 2,\r\n  DYNAMIC_DEFAULT_BROKER_CONFIG = 3,\r\n  STATIC_BROKER_CONFIG = 4,\r\n  DEFAULT_CONFIG = 5,\r\n  DYNAMIC_BROKER_LOGGER_CONFIG = 6,\r\n}\r\n\r\nexport enum AclPermissionTypes {\r\n  UNKNOWN = 0,\r\n  ANY = 1,\r\n  DENY = 2,\r\n  ALLOW = 3,\r\n}\r\n\r\nexport enum AclOperationTypes {\r\n  UNKNOWN = 0,\r\n  ANY = 1,\r\n  ALL = 2,\r\n  READ = 3,\r\n  WRITE = 4,\r\n  CREATE = 5,\r\n  DELETE = 6,\r\n  ALTER = 7,\r\n  DESCRIBE = 8,\r\n  CLUSTER_ACTION = 9,\r\n  DESCRIBE_CONFIGS = 10,\r\n  ALTER_CONFIGS = 11,\r\n  IDEMPOTENT_WRITE = 12,\r\n}\r\n\r\nexport enum ResourcePatternTypes {\r\n  UNKNOWN = 0,\r\n  ANY = 1,\r\n  MATCH = 2,\r\n  LITERAL = 3,\r\n  PREFIXED = 4,\r\n}\r\n\r\nexport interface ResourceConfigQuery {\r\n  type: ConfigResourceTypes;\r\n  name: string;\r\n  configNames?: string[];\r\n}\r\n\r\nexport interface ConfigEntries {\r\n  configName: string;\r\n  configValue: string;\r\n  isDefault: boolean;\r\n  configSource: ConfigSource;\r\n  isSensitive: boolean;\r\n  readOnly: boolean;\r\n  configSynonyms: ConfigSynonyms[];\r\n}\r\n\r\nexport interface ConfigSynonyms {\r\n  configName: string;\r\n  configValue: string;\r\n  configSource: ConfigSource;\r\n}\r\n\r\nexport interface DescribeConfigResponse {\r\n  resources: {\r\n    configEntries: ConfigEntries[];\r\n    errorCode: number;\r\n    errorMessage: string;\r\n    resourceName: string;\r\n    resourceType: ConfigResourceTypes;\r\n  }[];\r\n  throttleTime: number;\r\n}\r\n\r\nexport interface IResourceConfigEntry {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\nexport interface IResourceConfig {\r\n  type: ConfigResourceTypes;\r\n  name: string;\r\n  configEntries: IResourceConfigEntry[];\r\n}\r\n\r\ntype ValueOf<T> = T[keyof T];\r\n\r\nexport type AdminEvents = {\r\n  CONNECT: 'admin.connect';\r\n  DISCONNECT: 'admin.disconnect';\r\n  REQUEST: 'admin.network.request';\r\n  REQUEST_TIMEOUT: 'admin.network.request_timeout';\r\n  REQUEST_QUEUE_SIZE: 'admin.network.request_queue_size';\r\n};\r\n\r\nexport interface InstrumentationEvent<T> {\r\n  id: string;\r\n  type: string;\r\n  timestamp: number;\r\n  payload: T;\r\n}\r\n\r\nexport type RemoveInstrumentationEventListener<T> = () => void;\r\n\r\nexport type ConnectEvent = InstrumentationEvent<null>;\r\nexport type DisconnectEvent = InstrumentationEvent<null>;\r\nexport type RequestEvent = InstrumentationEvent<{\r\n  apiKey: number;\r\n  apiName: string;\r\n  apiVersion: number;\r\n  broker: string;\r\n  clientId: string;\r\n  correlationId: number;\r\n  createdAt: number;\r\n  duration: number;\r\n  pendingDuration: number;\r\n  sentAt: number;\r\n  size: number;\r\n}>;\r\nexport type RequestTimeoutEvent = InstrumentationEvent<{\r\n  apiKey: number;\r\n  apiName: string;\r\n  apiVersion: number;\r\n  broker: string;\r\n  clientId: string;\r\n  correlationId: number;\r\n  createdAt: number;\r\n  pendingDuration: number;\r\n  sentAt: number;\r\n}>;\r\nexport type RequestQueueSizeEvent = InstrumentationEvent<{\r\n  broker: string;\r\n  clientId: string;\r\n  queueSize: number;\r\n}>;\r\n\r\nexport type SeekEntry = PartitionOffset;\r\n\r\nexport type FetchOffsetsPartition = PartitionOffset & {\r\n  metadata: string | null;\r\n};\r\nexport interface Acl {\r\n  principal: string;\r\n  host: string;\r\n  operation: AclOperationTypes;\r\n  permissionType: AclPermissionTypes;\r\n}\r\n\r\nexport interface AclResource {\r\n  resourceType: AclResourceTypes;\r\n  resourceName: string;\r\n  resourcePatternType: ResourcePatternTypes;\r\n}\r\n\r\nexport type AclEntry = Acl & AclResource;\r\n\r\nexport type DescribeAclResource = AclResource & {\r\n  acls: Acl[];\r\n};\r\n\r\nexport interface DescribeAclResponse {\r\n  throttleTime: number;\r\n  errorCode: number;\r\n  errorMessage?: string;\r\n  resources: DescribeAclResource[];\r\n}\r\n\r\nexport interface AclFilter {\r\n  resourceType: AclResourceTypes;\r\n  resourceName?: string;\r\n  resourcePatternType: ResourcePatternTypes;\r\n  principal?: string;\r\n  host?: string;\r\n  operation: AclOperationTypes;\r\n  permissionType: AclPermissionTypes;\r\n}\r\n\r\nexport interface MatchingAcl {\r\n  errorCode: number;\r\n  errorMessage?: string;\r\n  resourceType: AclResourceTypes;\r\n  resourceName: string;\r\n  resourcePatternType: ResourcePatternTypes;\r\n  principal: string;\r\n  host: string;\r\n  operation: AclOperationTypes;\r\n  permissionType: AclPermissionTypes;\r\n}\r\n\r\nexport interface DeleteAclFilterResponses {\r\n  errorCode: number;\r\n  errorMessage?: string;\r\n  matchingAcls: MatchingAcl[];\r\n}\r\n\r\nexport interface DeleteAclResponse {\r\n  throttleTime: number;\r\n  filterResponses: DeleteAclFilterResponses[];\r\n}\r\n\r\nexport type Admin = {\r\n  connect(): Promise<void>;\r\n  disconnect(): Promise<void>;\r\n  listTopics(): Promise<string[]>;\r\n  createTopics(options: {\r\n    validateOnly?: boolean;\r\n    waitForLeaders?: boolean;\r\n    timeout?: number;\r\n    topics: ITopicConfig[];\r\n  }): Promise<boolean>;\r\n  deleteTopics(options: { topics: string[]; timeout?: number }): Promise<void>;\r\n  createPartitions(options: {\r\n    validateOnly?: boolean;\r\n    timeout?: number;\r\n    topicPartitions: ITopicPartitionConfig[];\r\n  }): Promise<boolean>;\r\n  fetchTopicMetadata(options?: {\r\n    topics: string[];\r\n  }): Promise<{ topics: Array<ITopicMetadata> }>;\r\n  fetchOffsets(options: {\r\n    groupId: string;\r\n    topics?: string[];\r\n    resolveOffsets?: boolean;\r\n  }): Promise<Array<{ topic: string; partitions: FetchOffsetsPartition[] }>>;\r\n  fetchTopicOffsets(\r\n    topic: string,\r\n  ): Promise<Array<SeekEntry & { high: string; low: string }>>;\r\n  fetchTopicOffsetsByTimestamp(\r\n    topic: string,\r\n    timestamp?: number,\r\n  ): Promise<Array<SeekEntry>>;\r\n  describeCluster(): Promise<{\r\n    brokers: Array<{ nodeId: number; host: string; port: number }>;\r\n    controller: number | null;\r\n    clusterId: string;\r\n  }>;\r\n  setOffsets(options: {\r\n    groupId: string;\r\n    topic: string;\r\n    partitions: SeekEntry[];\r\n  }): Promise<void>;\r\n  resetOffsets(options: {\r\n    groupId: string;\r\n    topic: string;\r\n    earliest: boolean;\r\n  }): Promise<void>;\r\n  describeConfigs(configs: {\r\n    resources: ResourceConfigQuery[];\r\n    includeSynonyms: boolean;\r\n  }): Promise<DescribeConfigResponse>;\r\n  alterConfigs(configs: {\r\n    validateOnly: boolean;\r\n    resources: IResourceConfig[];\r\n  }): Promise<any>;\r\n  listGroups(): Promise<{ groups: GroupOverview[] }>;\r\n  deleteGroups(groupIds: string[]): Promise<DeleteGroupsResult[]>;\r\n  describeGroups(groupIds: string[]): Promise<GroupDescriptions>;\r\n  describeAcls(options: AclFilter): Promise<DescribeAclResponse>;\r\n  deleteAcls(options: { filters: AclFilter[] }): Promise<DeleteAclResponse>;\r\n  createAcls(options: { acl: AclEntry[] }): Promise<boolean>;\r\n  deleteTopicRecords(options: {\r\n    topic: string;\r\n    partitions: SeekEntry[];\r\n  }): Promise<void>;\r\n  logger(): Logger;\r\n  on(\r\n    eventName: AdminEvents['CONNECT'],\r\n    listener: (event: ConnectEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: AdminEvents['DISCONNECT'],\r\n    listener: (event: DisconnectEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: AdminEvents['REQUEST'],\r\n    listener: (event: RequestEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: AdminEvents['REQUEST_QUEUE_SIZE'],\r\n    listener: (event: RequestQueueSizeEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: AdminEvents['REQUEST_TIMEOUT'],\r\n    listener: (event: RequestTimeoutEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ValueOf<AdminEvents>,\r\n    listener: (event: InstrumentationEvent<any>) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  readonly events: AdminEvents;\r\n};\r\n\r\nexport let PartitionAssigners: { roundRobin: PartitionAssigner };\r\n\r\nexport interface ISerializer<T> {\r\n  encode(value: T): Buffer;\r\n  decode(buffer: Buffer): T | null;\r\n}\r\n\r\nexport type MemberMetadata = {\r\n  version: number;\r\n  topics: string[];\r\n  userData: Buffer;\r\n};\r\n\r\nexport type MemberAssignment = {\r\n  version: number;\r\n  assignment: Assignment;\r\n  userData: Buffer;\r\n};\r\n\r\nexport let AssignerProtocol: {\r\n  MemberMetadata: ISerializer<MemberMetadata>;\r\n  MemberAssignment: ISerializer<MemberAssignment>;\r\n};\r\n\r\nexport enum logLevel {\r\n  NOTHING = 0,\r\n  ERROR = 1,\r\n  WARN = 2,\r\n  INFO = 4,\r\n  DEBUG = 5,\r\n}\r\n\r\nexport interface LogEntry {\r\n  namespace: string;\r\n  level: logLevel;\r\n  label: string;\r\n  log: LoggerEntryContent;\r\n}\r\n\r\nexport interface LoggerEntryContent {\r\n  readonly timestamp: string;\r\n  readonly message: string;\r\n  [key: string]: any;\r\n}\r\n\r\nexport type logCreator = (logLevel: logLevel) => (entry: LogEntry) => void;\r\n\r\nexport type Logger = {\r\n  info: (message: string, extra?: object) => void;\r\n  error: (message: string, extra?: object) => void;\r\n  warn: (message: string, extra?: object) => void;\r\n  debug: (message: string, extra?: object) => void;\r\n\r\n  namespace: (namespace: string, logLevel?: logLevel) => Logger;\r\n  setLogLevel: (logLevel: logLevel) => void;\r\n};\r\n\r\nexport interface BrokerMetadata {\r\n  brokers: Array<{ nodeId: number; host: string; port: number; rack?: string }>;\r\n  topicMetadata: Array<{\r\n    topicErrorCode: number;\r\n    topic: string;\r\n    partitionMetadata: PartitionMetadata[];\r\n  }>;\r\n}\r\n\r\nexport interface ApiVersions {\r\n  [apiKey: number]: {\r\n    minVersion: number;\r\n    maxVersion: number;\r\n  };\r\n}\r\n\r\nexport type Broker = {\r\n  isConnected(): boolean;\r\n  connect(): Promise<void>;\r\n  disconnect(): Promise<void>;\r\n  apiVersions(): Promise<ApiVersions>;\r\n  metadata(topics: string[]): Promise<BrokerMetadata>;\r\n  describeGroups: (options: { groupIds: string[] }) => Promise<any>;\r\n  offsetCommit(request: {\r\n    groupId: string;\r\n    groupGenerationId: number;\r\n    memberId: string;\r\n    retentionTime?: number;\r\n    topics: TopicOffsets[];\r\n  }): Promise<any>;\r\n  offsetFetch(request: { groupId: string; topics: TopicOffsets[] }): Promise<{\r\n    responses: TopicOffsets[];\r\n  }>;\r\n  fetch(request: {\r\n    replicaId?: number;\r\n    isolationLevel?: number;\r\n    maxWaitTime?: number;\r\n    minBytes?: number;\r\n    maxBytes?: number;\r\n    topics: Array<{\r\n      topic: string;\r\n      partitions: Array<{\r\n        partition: number;\r\n        fetchOffset: string;\r\n        maxBytes: number;\r\n      }>;\r\n    }>;\r\n    rackId?: string;\r\n  }): Promise<any>;\r\n  produce(request: {\r\n    topicData: Array<{\r\n      topic: string;\r\n      partitions: Array<{\r\n        partition: number;\r\n        firstSequence?: number;\r\n        messages: Message[];\r\n      }>;\r\n    }>;\r\n    transactionalId?: string;\r\n    producerId?: number;\r\n    producerEpoch?: number;\r\n    acks?: number;\r\n    timeout?: number;\r\n    compression?: CompressionTypes;\r\n  }): Promise<any>;\r\n};\r\n\r\ninterface MessageSetEntry {\r\n  key: Buffer | null;\r\n  value: Buffer | null;\r\n  timestamp: string;\r\n  attributes: number;\r\n  offset: string;\r\n  size: number;\r\n  headers?: never;\r\n}\r\n\r\ninterface RecordBatchEntry {\r\n  key: Buffer | null;\r\n  value: Buffer | null;\r\n  timestamp: string;\r\n  attributes: number;\r\n  offset: string;\r\n  headers: IHeaders;\r\n  size?: never;\r\n}\r\n\r\nexport type KafkaMessage = MessageSetEntry | RecordBatchEntry;\r\n\r\nexport interface ProducerRecord {\r\n  topic: string;\r\n  messages: Message[];\r\n  acks?: number;\r\n  timeout?: number;\r\n  compression?: CompressionTypes;\r\n}\r\n\r\nexport type RecordMetadata = {\r\n  topicName: string;\r\n  partition: number;\r\n  errorCode: number;\r\n  offset?: string;\r\n  timestamp?: string;\r\n  baseOffset?: string;\r\n  logAppendTime?: string;\r\n  logStartOffset?: string;\r\n};\r\n\r\nexport interface TopicMessages {\r\n  topic: string;\r\n  messages: Message[];\r\n}\r\n\r\nexport interface ProducerBatch {\r\n  acks?: number;\r\n  timeout?: number;\r\n  compression?: CompressionTypes;\r\n  topicMessages?: TopicMessages[];\r\n}\r\n\r\nexport interface PartitionOffset {\r\n  partition: number;\r\n  offset: string;\r\n}\r\n\r\nexport interface TopicOffsets {\r\n  topic: string;\r\n  partitions: PartitionOffset[];\r\n}\r\n\r\nexport interface Offsets {\r\n  topics: TopicOffsets[];\r\n}\r\n\r\ntype Sender = {\r\n  send(record: ProducerRecord): Promise<RecordMetadata[]>;\r\n  sendBatch(batch: ProducerBatch): Promise<RecordMetadata[]>;\r\n};\r\n\r\nexport type ProducerEvents = {\r\n  CONNECT: 'producer.connect';\r\n  DISCONNECT: 'producer.disconnect';\r\n  REQUEST: 'producer.network.request';\r\n  REQUEST_TIMEOUT: 'producer.network.request_timeout';\r\n  REQUEST_QUEUE_SIZE: 'producer.network.request_queue_size';\r\n};\r\n\r\nexport type Producer = Sender & {\r\n  connect(): Promise<void>;\r\n  disconnect(): Promise<void>;\r\n  isIdempotent(): boolean;\r\n  readonly events: ProducerEvents;\r\n  on(\r\n    eventName: ProducerEvents['CONNECT'],\r\n    listener: (event: ConnectEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ProducerEvents['DISCONNECT'],\r\n    listener: (event: DisconnectEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ProducerEvents['REQUEST'],\r\n    listener: (event: RequestEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ProducerEvents['REQUEST_QUEUE_SIZE'],\r\n    listener: (event: RequestQueueSizeEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ProducerEvents['REQUEST_TIMEOUT'],\r\n    listener: (event: RequestTimeoutEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ValueOf<ProducerEvents>,\r\n    listener: (event: InstrumentationEvent<any>) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  transaction(): Promise<Transaction>;\r\n  logger(): Logger;\r\n};\r\n\r\nexport type Transaction = Sender & {\r\n  sendOffsets(offsets: Offsets & { consumerGroupId: string }): Promise<void>;\r\n  commit(): Promise<void>;\r\n  abort(): Promise<void>;\r\n  isActive(): boolean;\r\n};\r\n\r\nexport type ConsumerGroup = {\r\n  groupId: string;\r\n  generationId: number;\r\n  memberId: string;\r\n  coordinator: Broker;\r\n};\r\n\r\nexport type MemberDescription = {\r\n  clientHost: string;\r\n  clientId: string;\r\n  memberId: string;\r\n  memberAssignment: Buffer;\r\n  memberMetadata: Buffer;\r\n};\r\n\r\n// See https://github.com/apache/kafka/blob/2.4.0/clients/src/main/java/org/apache/kafka/common/ConsumerGroupState.java#L25\r\nexport type ConsumerGroupState =\r\n  | 'Unknown'\r\n  | 'PreparingRebalance'\r\n  | 'CompletingRebalance'\r\n  | 'Stable'\r\n  | 'Dead'\r\n  | 'Empty';\r\n\r\nexport type GroupDescription = {\r\n  groupId: string;\r\n  members: MemberDescription[];\r\n  protocol: string;\r\n  protocolType: string;\r\n  state: ConsumerGroupState;\r\n};\r\n\r\nexport type GroupDescriptions = {\r\n  groups: GroupDescription[];\r\n};\r\n\r\nexport type TopicPartitions = { topic: string; partitions: number[] };\r\n\r\nexport type TopicPartition = {\r\n  topic: string;\r\n  partition: number;\r\n};\r\nexport type TopicPartitionOffset = TopicPartition & {\r\n  offset: string;\r\n};\r\nexport type TopicPartitionOffsetAndMetadata = TopicPartitionOffset & {\r\n  metadata?: string | null;\r\n};\r\n\r\nexport type Batch = {\r\n  topic: string;\r\n  partition: number;\r\n  highWatermark: string;\r\n  messages: KafkaMessage[];\r\n  isEmpty(): boolean;\r\n  firstOffset(): string | null;\r\n  lastOffset(): string;\r\n  offsetLag(): string;\r\n  offsetLagLow(): string;\r\n};\r\n\r\nexport type GroupOverview = {\r\n  groupId: string;\r\n  protocolType: string;\r\n};\r\n\r\nexport type DeleteGroupsResult = {\r\n  groupId: string;\r\n  errorCode?: number;\r\n  error?: KafkaJSProtocolError;\r\n};\r\n\r\nexport type ConsumerEvents = {\r\n  HEARTBEAT: 'consumer.heartbeat';\r\n  COMMIT_OFFSETS: 'consumer.commit_offsets';\r\n  GROUP_JOIN: 'consumer.group_join';\r\n  FETCH_START: 'consumer.fetch_start';\r\n  FETCH: 'consumer.fetch';\r\n  START_BATCH_PROCESS: 'consumer.start_batch_process';\r\n  END_BATCH_PROCESS: 'consumer.end_batch_process';\r\n  CONNECT: 'consumer.connect';\r\n  DISCONNECT: 'consumer.disconnect';\r\n  STOP: 'consumer.stop';\r\n  CRASH: 'consumer.crash';\r\n  REBALANCING: 'consumer.rebalancing';\r\n  RECEIVED_UNSUBSCRIBED_TOPICS: 'consumer.received_unsubscribed_topics';\r\n  REQUEST: 'consumer.network.request';\r\n  REQUEST_TIMEOUT: 'consumer.network.request_timeout';\r\n  REQUEST_QUEUE_SIZE: 'consumer.network.request_queue_size';\r\n};\r\nexport type ConsumerHeartbeatEvent = InstrumentationEvent<{\r\n  groupId: string;\r\n  memberId: string;\r\n  groupGenerationId: number;\r\n}>;\r\nexport type ConsumerCommitOffsetsEvent = InstrumentationEvent<{\r\n  groupId: string;\r\n  memberId: string;\r\n  groupGenerationId: number;\r\n  topics: TopicOffsets[];\r\n}>;\r\nexport interface IMemberAssignment {\r\n  [key: string]: number[];\r\n}\r\nexport type ConsumerGroupJoinEvent = InstrumentationEvent<{\r\n  duration: number;\r\n  groupId: string;\r\n  isLeader: boolean;\r\n  leaderId: string;\r\n  groupProtocol: string;\r\n  memberId: string;\r\n  memberAssignment: IMemberAssignment;\r\n}>;\r\nexport type ConsumerFetchStartEvent = InstrumentationEvent<{ nodeId: number }>;\r\nexport type ConsumerFetchEvent = InstrumentationEvent<{\r\n  numberOfBatches: number;\r\n  duration: number;\r\n  nodeId: number;\r\n}>;\r\ninterface IBatchProcessEvent {\r\n  topic: string;\r\n  partition: number;\r\n  highWatermark: string;\r\n  offsetLag: string;\r\n  offsetLagLow: string;\r\n  batchSize: number;\r\n  firstOffset: string;\r\n  lastOffset: string;\r\n}\r\nexport type ConsumerStartBatchProcessEvent =\r\n  InstrumentationEvent<IBatchProcessEvent>;\r\nexport type ConsumerEndBatchProcessEvent = InstrumentationEvent<\r\n  IBatchProcessEvent & { duration: number }\r\n>;\r\nexport type ConsumerCrashEvent = InstrumentationEvent<{\r\n  error: Error;\r\n  groupId: string;\r\n  restart: boolean;\r\n}>;\r\nexport type ConsumerRebalancingEvent = InstrumentationEvent<{\r\n  groupId: string;\r\n  memberId: string;\r\n}>;\r\nexport type ConsumerReceivedUnsubscribedTopicsEvent = InstrumentationEvent<{\r\n  groupId: string;\r\n  generationId: number;\r\n  memberId: string;\r\n  assignedTopics: string[];\r\n  topicsSubscribed: string[];\r\n  topicsNotSubscribed: string[];\r\n}>;\r\n\r\nexport interface OffsetsByTopicPartition {\r\n  topics: TopicOffsets[];\r\n}\r\n\r\nexport interface EachMessagePayload {\r\n  topic: string;\r\n  partition: number;\r\n  message: KafkaMessage;\r\n  heartbeat(): Promise<void>;\r\n  pause(): () => void;\r\n}\r\n\r\nexport interface EachBatchPayload {\r\n  batch: Batch;\r\n  resolveOffset(offset: string): void;\r\n  heartbeat(): Promise<void>;\r\n  pause(): () => void;\r\n  commitOffsetsIfNecessary(offsets?: Offsets): Promise<void>;\r\n  uncommittedOffsets(): OffsetsByTopicPartition;\r\n  isRunning(): boolean;\r\n  isStale(): boolean;\r\n}\r\n\r\n/**\r\n * Type alias to keep compatibility with @types/kafkajs\r\n * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/712ad9d59ccca6a3cc92f347fea0d1c7b02f5eeb/types/kafkajs/index.d.ts#L321-L325\r\n */\r\nexport type ConsumerEachMessagePayload = EachMessagePayload;\r\n\r\n/**\r\n * Type alias to keep compatibility with @types/kafkajs\r\n * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/712ad9d59ccca6a3cc92f347fea0d1c7b02f5eeb/types/kafkajs/index.d.ts#L327-L336\r\n */\r\nexport type ConsumerEachBatchPayload = EachBatchPayload;\r\n\r\nexport type EachBatchHandler = (payload: EachBatchPayload) => Promise<void>;\r\nexport type EachMessageHandler = (payload: EachMessagePayload) => Promise<void>;\r\n\r\nexport type ConsumerRunConfig = {\r\n  autoCommit?: boolean;\r\n  autoCommitInterval?: number | null;\r\n  autoCommitThreshold?: number | null;\r\n  eachBatchAutoResolve?: boolean;\r\n  partitionsConsumedConcurrently?: number;\r\n  eachBatch?: EachBatchHandler;\r\n  eachMessage?: EachMessageHandler;\r\n};\r\n\r\n/**\r\n * @deprecated Replaced by ConsumerSubscribeTopics\r\n */\r\nexport type ConsumerSubscribeTopic = {\r\n  topic: string | RegExp;\r\n  fromBeginning?: boolean;\r\n};\r\nexport type ConsumerSubscribeTopics = {\r\n  topics: (string | RegExp)[];\r\n  fromBeginning?: boolean;\r\n};\r\n\r\nexport type Consumer = {\r\n  connect(): Promise<void>;\r\n  disconnect(): Promise<void>;\r\n  subscribe(\r\n    subscription: ConsumerSubscribeTopics | ConsumerSubscribeTopic,\r\n  ): Promise<void>;\r\n  stop(): Promise<void>;\r\n  run(config?: ConsumerRunConfig): Promise<void>;\r\n  commitOffsets(\r\n    topicPartitions: Array<TopicPartitionOffsetAndMetadata>,\r\n  ): Promise<void>;\r\n  seek(topicPartitionOffset: TopicPartitionOffset): void;\r\n  describeGroup(): Promise<GroupDescription>;\r\n  pause(topics: Array<{ topic: string; partitions?: number[] }>): void;\r\n  paused(): TopicPartitions[];\r\n  resume(topics: Array<{ topic: string; partitions?: number[] }>): void;\r\n  on(\r\n    eventName: ConsumerEvents['HEARTBEAT'],\r\n    listener: (event: ConsumerHeartbeatEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['COMMIT_OFFSETS'],\r\n    listener: (event: ConsumerCommitOffsetsEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['GROUP_JOIN'],\r\n    listener: (event: ConsumerGroupJoinEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['FETCH_START'],\r\n    listener: (event: ConsumerFetchStartEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['FETCH'],\r\n    listener: (event: ConsumerFetchEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['START_BATCH_PROCESS'],\r\n    listener: (event: ConsumerStartBatchProcessEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['END_BATCH_PROCESS'],\r\n    listener: (event: ConsumerEndBatchProcessEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['CONNECT'],\r\n    listener: (event: ConnectEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['DISCONNECT'],\r\n    listener: (event: DisconnectEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['STOP'],\r\n    listener: (event: InstrumentationEvent<null>) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['CRASH'],\r\n    listener: (event: ConsumerCrashEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['REBALANCING'],\r\n    listener: (event: ConsumerRebalancingEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['RECEIVED_UNSUBSCRIBED_TOPICS'],\r\n    listener: (event: ConsumerReceivedUnsubscribedTopicsEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['REQUEST'],\r\n    listener: (event: RequestEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['REQUEST_TIMEOUT'],\r\n    listener: (event: RequestTimeoutEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ConsumerEvents['REQUEST_QUEUE_SIZE'],\r\n    listener: (event: RequestQueueSizeEvent) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  on(\r\n    eventName: ValueOf<ConsumerEvents>,\r\n    listener: (event: InstrumentationEvent<any>) => void,\r\n  ): RemoveInstrumentationEventListener<typeof eventName>;\r\n  logger(): Logger;\r\n  readonly events: ConsumerEvents;\r\n};\r\n\r\nexport enum CompressionTypes {\r\n  None = 0,\r\n  GZIP = 1,\r\n  Snappy = 2,\r\n  LZ4 = 3,\r\n  ZSTD = 4,\r\n}\r\n\r\nexport let CompressionCodecs: {\r\n  [CompressionTypes.GZIP]: () => any;\r\n  [CompressionTypes.Snappy]: () => any;\r\n  [CompressionTypes.LZ4]: () => any;\r\n  [CompressionTypes.ZSTD]: () => any;\r\n};\r\n\r\nexport declare class KafkaJSError extends Error {\r\n  readonly message: Error['message'];\r\n  readonly name: string;\r\n  readonly retriable: boolean;\r\n  readonly helpUrl?: string;\r\n  readonly cause?: Error;\r\n\r\n  constructor(e: Error | string, metadata?: KafkaJSErrorMetadata);\r\n}\r\n\r\nexport declare class KafkaJSNonRetriableError extends KafkaJSError {\r\n  constructor(e: Error | string);\r\n}\r\n\r\nexport declare class KafkaJSProtocolError extends KafkaJSError {\r\n  readonly code: number;\r\n  readonly type: string;\r\n  constructor(e: Error | string);\r\n}\r\n\r\nexport declare class KafkaJSOffsetOutOfRange extends KafkaJSProtocolError {\r\n  readonly topic: string;\r\n  readonly partition: number;\r\n  constructor(e: Error | string, metadata?: KafkaJSOffsetOutOfRangeMetadata);\r\n}\r\n\r\nexport declare class KafkaJSNumberOfRetriesExceeded extends KafkaJSNonRetriableError {\r\n  readonly stack: string;\r\n  readonly retryCount: number;\r\n  readonly retryTime: number;\r\n  constructor(\r\n    e: Error | string,\r\n    metadata?: KafkaJSNumberOfRetriesExceededMetadata,\r\n  );\r\n}\r\n\r\nexport declare class KafkaJSConnectionError extends KafkaJSError {\r\n  readonly broker: string;\r\n  constructor(e: Error | string, metadata?: KafkaJSConnectionErrorMetadata);\r\n}\r\n\r\nexport declare class KafkaJSRequestTimeoutError extends KafkaJSError {\r\n  readonly broker: string;\r\n  readonly correlationId: number;\r\n  readonly createdAt: number;\r\n  readonly sentAt: number;\r\n  readonly pendingDuration: number;\r\n  constructor(e: Error | string, metadata?: KafkaJSRequestTimeoutErrorMetadata);\r\n}\r\n\r\nexport declare class KafkaJSMetadataNotLoaded extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSTopicMetadataNotLoaded extends KafkaJSMetadataNotLoaded {\r\n  readonly topic: string;\r\n  constructor(\r\n    e: Error | string,\r\n    metadata?: KafkaJSTopicMetadataNotLoadedMetadata,\r\n  );\r\n}\r\n\r\nexport declare class KafkaJSStaleTopicMetadataAssignment extends KafkaJSError {\r\n  readonly topic: string;\r\n  readonly unknownPartitions: number;\r\n  constructor(\r\n    e: Error | string,\r\n    metadata?: KafkaJSStaleTopicMetadataAssignmentMetadata,\r\n  );\r\n}\r\n\r\nexport declare class KafkaJSServerDoesNotSupportApiKey extends KafkaJSNonRetriableError {\r\n  readonly apiKey: number;\r\n  readonly apiName: string;\r\n  constructor(\r\n    e: Error | string,\r\n    metadata?: KafkaJSServerDoesNotSupportApiKeyMetadata,\r\n  );\r\n}\r\n\r\nexport declare class KafkaJSBrokerNotFound extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSPartialMessageError extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSSASLAuthenticationError extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSGroupCoordinatorNotFound extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSNotImplemented extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSTimeout extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSLockTimeout extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSUnsupportedMagicByteInMessageSet extends KafkaJSError {\r\n  constructor();\r\n}\r\n\r\nexport declare class KafkaJSDeleteGroupsError extends KafkaJSError {\r\n  readonly groups: DeleteGroupsResult[];\r\n  constructor(e: Error | string, groups?: KafkaJSDeleteGroupsErrorGroups[]);\r\n}\r\n\r\nexport declare class KafkaJSDeleteTopicRecordsError extends KafkaJSError {\r\n  constructor(metadata: KafkaJSDeleteTopicRecordsErrorTopic);\r\n}\r\n\r\nexport interface KafkaJSDeleteGroupsErrorGroups {\r\n  groupId: string;\r\n  errorCode: number;\r\n  error: KafkaJSError;\r\n}\r\n\r\nexport interface KafkaJSDeleteTopicRecordsErrorTopic {\r\n  topic: string;\r\n  partitions: KafkaJSDeleteTopicRecordsErrorPartition[];\r\n}\r\n\r\nexport interface KafkaJSDeleteTopicRecordsErrorPartition {\r\n  partition: number;\r\n  offset: string;\r\n  error: KafkaJSError;\r\n}\r\n\r\nexport interface KafkaJSErrorMetadata {\r\n  retriable?: boolean;\r\n  topic?: string;\r\n  partitionId?: number;\r\n  metadata?: PartitionMetadata;\r\n}\r\n\r\nexport interface KafkaJSOffsetOutOfRangeMetadata {\r\n  topic: string;\r\n  partition: number;\r\n}\r\n\r\nexport interface KafkaJSNumberOfRetriesExceededMetadata {\r\n  retryCount: number;\r\n  retryTime: number;\r\n}\r\n\r\nexport interface KafkaJSConnectionErrorMetadata {\r\n  broker?: string;\r\n  code?: string;\r\n}\r\n\r\nexport interface KafkaJSRequestTimeoutErrorMetadata {\r\n  broker: string;\r\n  clientId: string;\r\n  correlationId: number;\r\n  createdAt: number;\r\n  sentAt: number;\r\n  pendingDuration: number;\r\n}\r\n\r\nexport interface KafkaJSTopicMetadataNotLoadedMetadata {\r\n  topic: string;\r\n}\r\n\r\nexport interface KafkaJSStaleTopicMetadataAssignmentMetadata {\r\n  topic: string;\r\n  unknownPartitions: PartitionMetadata[];\r\n}\r\n\r\nexport interface KafkaJSServerDoesNotSupportApiKeyMetadata {\r\n  apiKey: number;\r\n  apiName: string;\r\n}\r\n"]}