{"version":3,"file":"mqtt-client.interface.js","sourceRoot":"","sources":["mqtt-client.interface.ts"],"names":[],"mappings":";;AAAA,mCAAsC","sourcesContent":["import { EventEmitter } from 'events';\r\n\r\n/**\r\n * @see https://github.com/mqttjs/MQTT.js/\r\n *\r\n * @publicApi\r\n *\r\n */\r\nexport declare class MqttClient extends EventEmitter {\r\n  public connected: boolean;\r\n  public disconnecting: boolean;\r\n  public disconnected: boolean;\r\n  public reconnecting: boolean;\r\n  public incomingStore: any;\r\n  public outgoingStore: any;\r\n  public options: any;\r\n  public queueQoSZero: boolean;\r\n\r\n  constructor(streamBuilder: (client: MqttClient) => any, options: any);\r\n\r\n  public on(event: 'message', cb: any): this;\r\n  public on(event: 'packetsend' | 'packetreceive', cb: any): this;\r\n  public on(event: 'error', cb: any): this;\r\n  public on(event: string, cb: Function): this;\r\n\r\n  public once(event: 'message', cb: any): this;\r\n  public once(event: 'packetsend' | 'packetreceive', cb: any): this;\r\n  public once(event: 'error', cb: any): this;\r\n  public once(event: string, cb: Function): this;\r\n\r\n  /**\r\n   * publish - publish <message> to <topic>\r\n   *\r\n   * @param {String} topic - topic to publish to\r\n   * @param {(String|Buffer)} message - message to publish\r\n   *\r\n   * @param {Object}    [opts] - publish options, includes:\r\n   *   @param {Number}  [opts.qos] - qos level to publish on\r\n   *   @param {Boolean} [opts.retain] - whether or not to retain the message\r\n   *\r\n   * @param {Function} [callback] - function(err){}\r\n   *    called when publish succeeds or fails\r\n   * @returns {Client} this - for chaining\r\n   * @api public\r\n   *\r\n   * @example client.publish('topic', 'message')\r\n   * @example\r\n   *     client.publish('topic', 'message', {qos: 1, retain: true})\r\n   * @example client.publish('topic', 'message', console.log)\r\n   */\r\n  public publish(\r\n    topic: string,\r\n    message: string | Buffer,\r\n    opts: any,\r\n    callback?: any,\r\n  ): this;\r\n  public publish(topic: string, message: string | Buffer, callback?: any): this;\r\n\r\n  /**\r\n   * subscribe - subscribe to <topic>\r\n   *\r\n   * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\r\n   * @param {Object} [opts] - optional subscription options, includes:\r\n   * @param  {Number} [opts.qos] - subscribe qos level\r\n   * @param {Function} [callback] - function(err, granted){} where:\r\n   *    {Error} err - subscription error (none at the moment!)\r\n   *    {Array} granted - array of {topic: 't', qos: 0}\r\n   * @returns {MqttClient} this - for chaining\r\n   * @api public\r\n   * @example client.subscribe('topic')\r\n   * @example client.subscribe('topic', {qos: 1})\r\n   * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log)\r\n   * @example client.subscribe('topic', console.log)\r\n   */\r\n  public subscribe(topic: string | string[], opts: any, callback?: any): this;\r\n  public subscribe(topic: string | string[] | any, callback?: any): this;\r\n\r\n  /**\r\n   * unsubscribe - unsubscribe from topic(s)\r\n   *\r\n   * @param {string|Array} topic - topics to unsubscribe from\r\n   * @param {Function} [callback] - callback fired on unsuback\r\n   * @returns {MqttClient} this - for chaining\r\n   * @api public\r\n   * @example client.unsubscribe('topic')\r\n   * @example client.unsubscribe('topic', console.log)\r\n   */\r\n  public unsubscribe(topic: string | string[], callback?: any): this;\r\n\r\n  /**\r\n   * end - close connection\r\n   *\r\n   * @returns {MqttClient} this - for chaining\r\n   * @param {Boolean} force - do not wait for all in-flight messages to be acked\r\n   * @param {Function} cb - called when the client has been closed\r\n   *\r\n   * @api public\r\n   */\r\n  public end(force?: boolean, cb?: any): this;\r\n\r\n  /**\r\n   * removeOutgoingMessage - remove a message in outgoing store\r\n   * the outgoing callback will be called withe Error('Message removed') if the message is removed\r\n   *\r\n   * @param {Number} mid - messageId to remove message\r\n   * @returns {MqttClient} this - for chaining\r\n   * @api public\r\n   *\r\n   * @example client.removeOutgoingMessage(client.getLastMessageId());\r\n   */\r\n  public removeOutgoingMessage(mid: number): this;\r\n\r\n  /**\r\n   * reconnect - connect again using the same options as connect()\r\n   *\r\n   * @param {Object} [opts] - optional reconnect options, includes:\r\n   *    {any} incomingStore - a store for the incoming packets\r\n   *    {any} outgoingStore - a store for the outgoing packets\r\n   *    if opts is not given, current stores are used\r\n   *\r\n   * @returns {MqttClient} this - for chaining\r\n   *\r\n   * @api public\r\n   */\r\n  public reconnect(opts?: any): this;\r\n\r\n  /**\r\n   * Handle messages with backpressure support, one at a time.\r\n   * Override at will.\r\n   *\r\n   * @param packet packet the packet\r\n   * @param callback callback call when finished\r\n   * @api public\r\n   */\r\n  public handleMessage(packet: any, callback: any): void;\r\n\r\n  /**\r\n   * getLastMessageId\r\n   */\r\n  public getLastMessageId(): number;\r\n}\r\n"]}