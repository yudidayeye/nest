{"version":3,"file":"mqtt-options.interface.js","sourceRoot":"","sources":["mqtt-options.interface.ts"],"names":[],"mappings":"","sourcesContent":["/**\r\n * @see https://github.com/mqttjs/MQTT.js/\r\n *\r\n * @publicApi\r\n */\r\nexport declare type QoS = 0 | 1 | 2;\r\n\r\nexport interface MqttClientOptions extends ISecureClientOptions {\r\n  port?: number; // port is made into a number subsequently\r\n  host?: string; // host does NOT include port\r\n  hostname?: string;\r\n  path?: string;\r\n  protocol?: 'wss' | 'ws' | 'mqtt' | 'mqtts' | 'tcp' | 'ssl' | 'wx' | 'wxs';\r\n\r\n  wsOptions?: {\r\n    [x: string]: any;\r\n  };\r\n  /**\r\n   *  10 seconds, set to 0 to disable\r\n   */\r\n  keepalive?: number;\r\n  /**\r\n   * 'mqttjs_' + Math.random().toString(16).substr(2, 8)\r\n   */\r\n  clientId?: string;\r\n  /**\r\n   * 'MQTT'\r\n   */\r\n  protocolId?: string;\r\n  /**\r\n   * 4\r\n   */\r\n  protocolVersion?: number;\r\n  /**\r\n   * true, set to false to receive QoS 1 and 2 messages while offline\r\n   */\r\n  clean?: boolean;\r\n  /**\r\n   * 1000 milliseconds, interval between two reconnections\r\n   */\r\n  reconnectPeriod?: number;\r\n  /**\r\n   * 30 * 1000 milliseconds, time to wait before a CONNACK is received\r\n   */\r\n  connectTimeout?: number;\r\n  /**\r\n   * the username required by your broker, if any\r\n   */\r\n  username?: string;\r\n  /**\r\n   * the password required by your broker, if any\r\n   */\r\n  password?: string;\r\n  /**\r\n   * a any for the incoming packets\r\n   */\r\n  incomingStore?: any;\r\n  /**\r\n   * a any for the outgoing packets\r\n   */\r\n  outgoingStore?: any;\r\n  queueQoSZero?: boolean;\r\n  reschedulePings?: boolean;\r\n  servers?: Array<{\r\n    host: string;\r\n    port: number;\r\n  }>;\r\n  /**\r\n   * true, set to false to disable re-subscribe functionality\r\n   */\r\n  resubscribe?: boolean;\r\n  /**\r\n   * a message that will sent by the broker automatically when the client disconnect badly.\r\n   */\r\n  will?: {\r\n    /**\r\n     * the topic to publish\r\n     */\r\n    topic: string;\r\n    /**\r\n     * the message to publish\r\n     */\r\n    payload: string;\r\n    /**\r\n     * the QoS\r\n     */\r\n    qos: QoS;\r\n    /**\r\n     * the retain flag\r\n     */\r\n    retain: boolean;\r\n  };\r\n  transformWsUrl?: (url: string, options: any, client: any) => string;\r\n}\r\nexport interface ISecureClientOptions {\r\n  /**\r\n   * optional private keys in PEM format\r\n   */\r\n  key?: string | string[] | Buffer | Buffer[] | Record<string, any>[];\r\n  /**\r\n   * optional cert chains in PEM format\r\n   */\r\n  cert?: string | string[] | Buffer | Buffer[];\r\n  /**\r\n   * Optionally override the trusted CA certificates in PEM format\r\n   */\r\n  ca?: string | string[] | Buffer | Buffer[];\r\n  rejectUnauthorized?: boolean;\r\n}\r\nexport interface IClientPublishOptions {\r\n  /**\r\n   * the QoS\r\n   */\r\n  qos: QoS;\r\n  /**\r\n   * the retain flag\r\n   */\r\n  retain?: boolean;\r\n  /**\r\n   * whether or not mark a message as duplicate\r\n   */\r\n  dup?: boolean;\r\n}\r\nexport interface IClientSubscribeOptions {\r\n  /**\r\n   * the QoS\r\n   */\r\n  qos: QoS;\r\n}\r\nexport interface IClientReconnectOptions {\r\n  /**\r\n   * a any for the incoming packets\r\n   */\r\n  incomingStore?: any;\r\n  /**\r\n   * a any for the outgoing packets\r\n   */\r\n  outgoingStore?: any;\r\n}\r\n"]}