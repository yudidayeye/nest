{"version":3,"file":"redis.interface.js","sourceRoot":"","sources":["redis.interface.ts"],"names":[],"mappings":"","sourcesContent":["import { ConnectionOptions } from 'tls';\r\n\r\n/**\r\n * @see https://github.dev/luin/ioredis/blob/df04dd8d87a44d3b64b385c86581915248554508/lib/redis/RedisOptions.ts#L184\r\n *\r\n * @publicApi\r\n */\r\nexport interface IORedisOptions {\r\n  Connector?: any;\r\n  retryStrategy?: (times: number) => number | void | null;\r\n\r\n  /**\r\n   * If a command does not return a reply within a set number of milliseconds,\r\n   * a \"Command timed out\" error will be thrown.\r\n   */\r\n  commandTimeout?: number;\r\n  /**\r\n   * Enable/disable keep-alive functionality.\r\n   * @link https://nodejs.org/api/net.html#socketsetkeepaliveenable-initialdelay\r\n   * @default 0\r\n   */\r\n  keepAlive?: number;\r\n\r\n  /**\r\n   * Enable/disable the use of Nagle's algorithm.\r\n   * @link https://nodejs.org/api/net.html#socketsetnodelaynodelay\r\n   * @default true\r\n   */\r\n  noDelay?: boolean;\r\n\r\n  /**\r\n   * Set the name of the connection to make it easier to identity the connection\r\n   * in client list.\r\n   * @link https://redis.io/commands/client-setname\r\n   */\r\n  connectionName?: string;\r\n\r\n  /**\r\n   * If set, client will send AUTH command with the value of this option as the first argument when connected.\r\n   * This is supported since Redis 6.\r\n   */\r\n  username?: string;\r\n\r\n  /**\r\n   * If set, client will send AUTH command with the value of this option when connected.\r\n   */\r\n  password?: string;\r\n\r\n  /**\r\n   * Database index to use.\r\n   *\r\n   * @default 0\r\n   */\r\n  db?: number;\r\n\r\n  /**\r\n   * When the client reconnects, channels subscribed in the previous connection will be\r\n   * resubscribed automatically if `autoResubscribe` is `true`.\r\n   * @default true\r\n   */\r\n  autoResubscribe?: boolean;\r\n\r\n  /**\r\n   * Whether or not to resend unfulfilled commands on reconnect.\r\n   * Unfulfilled commands are most likely to be blocking commands such as `brpop` or `blpop`.\r\n   * @default true\r\n   */\r\n  autoResendUnfulfilledCommands?: boolean;\r\n  /**\r\n   * Whether or not to reconnect on certain Redis errors.\r\n   * This options by default is `null`, which means it should never reconnect on Redis errors.\r\n   * You can pass a function that accepts an Redis error, and returns:\r\n   * - `true` or `1` to trigger a reconnection.\r\n   * - `false` or `0` to not reconnect.\r\n   * - `2` to reconnect and resend the failed command (who triggered the error) after reconnection.\r\n   * @example\r\n   * ```js\r\n   * const redis = new Redis({\r\n   *   reconnectOnError(err) {\r\n   *     const targetError = \"READONLY\";\r\n   *     if (err.message.includes(targetError)) {\r\n   *       // Only reconnect when the error contains \"READONLY\"\r\n   *       return true; // or `return 1;`\r\n   *     }\r\n   *   },\r\n   * });\r\n   * ```\r\n   * @default null\r\n   */\r\n  reconnectOnError?: ((err: Error) => boolean | 1 | 2) | null;\r\n\r\n  /**\r\n   * @default false\r\n   */\r\n  readOnly?: boolean;\r\n  /**\r\n   * When enabled, numbers returned by Redis will be converted to JavaScript strings instead of numbers.\r\n   * This is necessary if you want to handle big numbers (above `Number.MAX_SAFE_INTEGER` === 2^53).\r\n   * @default false\r\n   */\r\n  stringNumbers?: boolean;\r\n\r\n  /**\r\n   * How long the client will wait before killing a socket due to inactivity during initial connection.\r\n   * @default 10000\r\n   */\r\n  connectTimeout?: number;\r\n\r\n  /**\r\n   * This option is used internally when you call `redis.monitor()` to tell Redis\r\n   * to enter the monitor mode when the connection is established.\r\n   *\r\n   * @default false\r\n   */\r\n  monitor?: boolean;\r\n\r\n  /**\r\n   * The commands that don't get a reply due to the connection to the server is lost are\r\n   * put into a queue and will be resent on reconnect (if allowed by the `retryStrategy` option).\r\n   * This option is used to configure how many reconnection attempts should be allowed before\r\n   * the queue is flushed with a `MaxRetriesPerRequestError` error.\r\n   * Set this options to `null` instead of a number to let commands wait forever\r\n   * until the connection is alive again.\r\n   *\r\n   * @default 20\r\n   */\r\n  maxRetriesPerRequest?: number | null;\r\n\r\n  /**\r\n   * @default 10000\r\n   */\r\n  maxLoadingRetryTime?: number;\r\n  /**\r\n   * @default false\r\n   */\r\n  enableAutoPipelining?: boolean;\r\n  /**\r\n   * @default []\r\n   */\r\n  autoPipeliningIgnoredCommands?: string[];\r\n  offlineQueue?: boolean;\r\n  commandQueue?: boolean;\r\n\r\n  /**\r\n   *\r\n   * By default, if the connection to Redis server has not been established, commands are added to a queue\r\n   * and are executed once the connection is \"ready\" (when `enableReadyCheck` is true, \"ready\" means\r\n   * the Redis server has loaded the database from disk, otherwise means the connection to the Redis\r\n   * server has been established). If this option is false, when execute the command when the connection\r\n   * isn't ready, an error will be returned.\r\n   *\r\n   * @default true\r\n   */\r\n  enableOfflineQueue?: boolean;\r\n\r\n  /**\r\n   * The client will sent an INFO command to check whether the server is still loading data from the disk (\r\n   * which happens when the server is just launched) when the connection is established, and only wait until\r\n   * the loading process is finished before emitting the `ready` event.\r\n   *\r\n   * @default true\r\n   */\r\n  enableReadyCheck?: boolean;\r\n\r\n  /**\r\n   * When a Redis instance is initialized, a connection to the server is immediately established. Set this to\r\n   * true will delay the connection to the server until the first command is sent or `redis.connect()` is called\r\n   * explicitly.\r\n   *\r\n   * @default false\r\n   */\r\n\r\n  lazyConnect?: boolean;\r\n\r\n  /**\r\n   * @default undefined\r\n   */\r\n  scripts?: Record<\r\n    string,\r\n    { lua: string; numberOfKeys?: number; readOnly?: boolean }\r\n  >;\r\n\r\n  keyPrefix?: string;\r\n  showFriendlyErrorStack?: boolean;\r\n\r\n  // StandaloneConnectionOptions\r\n  disconnectTimeout?: number;\r\n  tls?: ConnectionOptions;\r\n\r\n  // SentinelConnectionOptions\r\n  /**\r\n   * Master group name of the Sentinel\r\n   */\r\n  name?: string;\r\n  /**\r\n   * @default \"master\"\r\n   */\r\n  role?: 'master' | 'slave';\r\n  sentinelUsername?: string;\r\n  sentinelPassword?: string;\r\n  sentinels?: Array<Partial<any>>;\r\n  sentinelRetryStrategy?: (retryAttempts: number) => number | void | null;\r\n  sentinelReconnectStrategy?: (retryAttempts: number) => number | void | null;\r\n  preferredSlaves?: any;\r\n  sentinelCommandTimeout?: number;\r\n  enableTLSForSentinelMode?: boolean;\r\n  sentinelTLS?: ConnectionOptions;\r\n  natMap?: any;\r\n  updateSentinels?: boolean;\r\n  /**\r\n   * @default 10\r\n   */\r\n  sentinelMaxConnections?: number;\r\n  failoverDetector?: boolean;\r\n}\r\n"]}