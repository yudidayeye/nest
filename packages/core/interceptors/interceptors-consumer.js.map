{"version":3,"file":"interceptors-consumer.js","sourceRoot":"D:/04-learn-font/learn-node/nest/packages/core/","sources":["interceptors/interceptors-consumer.ts"],"names":[],"mappings":";;;AAMA,oEAA4D;AAC5D,6CAA4C;AAC5C,+BAA8D;AAC9D,8CAAqD;AACrD,8EAAyE;AAEzE,MAAa,oBAAoB;IACxB,KAAK,CAAC,SAAS,CACpB,YAA+B,EAC/B,IAAe,EACf,QAAoB,EACpB,QAAyC,EACzC,IAA4B,EAC5B,IAAe;QAEf,IAAI,IAAA,sBAAO,EAAC,YAAY,CAAC,EAAE;YACzB,OAAO,IAAI,EAAE,CAAC;SACf;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC7D,OAAO,CAAC,OAAO,CAAW,IAAI,CAAC,CAAC;QAEhC,MAAM,MAAM,GAAG,KAAK,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE;YAC7B,IAAI,CAAC,IAAI,YAAY,CAAC,MAAM,EAAE;gBAC5B,OAAO,IAAA,YAAK,EAAC,2BAAa,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aACtE;YACD,MAAM,OAAO,GAAgB;gBAC3B,MAAM,EAAE,GAAG,EAAE,CAAC,IAAA,WAAW,EAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAA,oBAAQ,GAAE,CAAC;aAC1D,CAAC;YACF,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACrD,CAAC,CAAC;QACF,OAAO,IAAA,YAAK,EAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,IAAA,oBAAQ,GAAE,CAAC,CAAC;IAChD,CAAC;IAEM,aAAa,CAClB,IAAe,EACf,QAAoB,EACpB,QAAyC;QAEzC,OAAO,IAAI,6CAAoB,CAC7B,IAAI,EACJ,QAAQ,CAAC,WAA4B,EACrC,QAAQ,CACT,CAAC;IACJ,CAAC;IAEM,iBAAiB,CAAC,IAAwB;QAC/C,OAAO,IAAA,WAAW,EAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAC7B,IAAA,qBAAS,EAAC,GAAG,CAAC,EAAE;YACd,MAAM,UAAU,GAAG,GAAG,YAAY,OAAO,IAAI,GAAG,YAAY,iBAAU,CAAC;YACvE,OAAO,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACjD,CAAC,CAAC,CACH,CAAC;IACJ,CAAC;CACF;AA/CD,oDA+CC","sourcesContent":["import { NestInterceptor, Type } from '@nestjs/common';\r\nimport {\r\n  CallHandler,\r\n  ContextType,\r\n  Controller,\r\n} from '@nestjs/common/interfaces';\r\nimport { isEmpty } from '@nestjs/common/utils/shared.utils';\r\nimport { AsyncResource } from 'async_hooks';\r\nimport { Observable, defer, from as fromPromise } from 'rxjs';\r\nimport { mergeAll, switchMap } from 'rxjs/operators';\r\nimport { ExecutionContextHost } from '../helpers/execution-context-host';\r\n\r\nexport class InterceptorsConsumer {\r\n  public async intercept<TContext extends string = ContextType>(\r\n    interceptors: NestInterceptor[],\r\n    args: unknown[],\r\n    instance: Controller,\r\n    callback: (...args: unknown[]) => unknown,\r\n    next: () => Promise<unknown>,\r\n    type?: TContext,\r\n  ): Promise<unknown> {\r\n    if (isEmpty(interceptors)) {\r\n      return next();\r\n    }\r\n    const context = this.createContext(args, instance, callback);\r\n    context.setType<TContext>(type);\r\n\r\n    const nextFn = async (i = 0) => {\r\n      if (i >= interceptors.length) {\r\n        return defer(AsyncResource.bind(() => this.transformDeferred(next)));\r\n      }\r\n      const handler: CallHandler = {\r\n        handle: () => fromPromise(nextFn(i + 1)).pipe(mergeAll()),\r\n      };\r\n      return interceptors[i].intercept(context, handler);\r\n    };\r\n    return defer(() => nextFn()).pipe(mergeAll());\r\n  }\r\n\r\n  public createContext(\r\n    args: unknown[],\r\n    instance: Controller,\r\n    callback: (...args: unknown[]) => unknown,\r\n  ): ExecutionContextHost {\r\n    return new ExecutionContextHost(\r\n      args,\r\n      instance.constructor as Type<unknown>,\r\n      callback,\r\n    );\r\n  }\r\n\r\n  public transformDeferred(next: () => Promise<any>): Observable<any> {\r\n    return fromPromise(next()).pipe(\r\n      switchMap(res => {\r\n        const isDeferred = res instanceof Promise || res instanceof Observable;\r\n        return isDeferred ? res : Promise.resolve(res);\r\n      }),\r\n    );\r\n  }\r\n}\r\n"]}