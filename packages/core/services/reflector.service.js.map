{"version":3,"file":"reflector.service.js","sourceRoot":"D:/04-learn-font/learn-node/nest/packages/core/","sources":["services/reflector.service.ts"],"names":[],"mappings":";;;AACA,oEAAsE;AAEtE;;;;;;GAMG;AACH,MAAa,SAAS;IACpB;;;;;;;;;OASG;IACI,GAAG,CACR,WAAiB,EACjB,MAA4B;QAE5B,OAAO,OAAO,CAAC,WAAW,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;IAClD,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CACX,WAAiB,EACjB,OAAiC;QAEjC,OAAO,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAClC,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,MAAM,CAAC,CACnB,CAAC;IACf,CAAC;IAED;;;;;;OAMG;IACI,cAAc,CACnB,WAAiB,EACjB,OAAiC;QAEjC,MAAM,kBAAkB,GAAG,IAAI,CAAC,MAAM,CACpC,WAAW,EACX,OAAO,CACR,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;QAErC,IAAI,IAAA,sBAAO,EAAC,kBAAkB,CAAC,EAAE;YAC/B,OAAO,kBAA6B,CAAC;SACtC;QACD,OAAO,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YACxC,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;gBACpB,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;aACpB;YACD,IAAI,IAAA,uBAAQ,EAAC,CAAC,CAAC,IAAI,IAAA,uBAAQ,EAAC,CAAC,CAAC,EAAE;gBAC9B,OAAO;oBACL,GAAG,CAAC;oBACJ,GAAG,CAAC;iBACL,CAAC;aACH;YACD,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACI,iBAAiB,CACtB,WAAiB,EACjB,OAAiC;QAEjC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;YAC5B,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;YAC7C,IAAI,MAAM,KAAK,SAAS,EAAE;gBACxB,OAAO,MAAM,CAAC;aACf;SACF;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;CACF;AAtFD,8BAsFC","sourcesContent":["import { Type } from '@nestjs/common';\r\nimport { isEmpty, isObject } from '@nestjs/common/utils/shared.utils';\r\n\r\n/**\r\n * Helper class providing Nest reflection capabilities.\r\n *\r\n * @see [Reflection](https://docs.nestjs.com/guards#putting-it-all-together)\r\n *\r\n * @publicApi\r\n */\r\nexport class Reflector {\r\n  /**\r\n   * Retrieve metadata for a specified key for a specified target.\r\n   *\r\n   * @example\r\n   * `const roles = this.reflector.get<string[]>('roles', context.getHandler());`\r\n   *\r\n   * @param metadataKey lookup key for metadata to retrieve\r\n   * @param target context (decorated object) to retrieve metadata from\r\n   *\r\n   */\r\n  public get<TResult = any, TKey = any>(\r\n    metadataKey: TKey,\r\n    target: Type<any> | Function,\r\n  ): TResult {\r\n    return Reflect.getMetadata(metadataKey, target);\r\n  }\r\n\r\n  /**\r\n   * Retrieve metadata for a specified key for a specified set of targets.\r\n   *\r\n   * @param metadataKey lookup key for metadata to retrieve\r\n   * @param targets context (decorated objects) to retrieve metadata from\r\n   *\r\n   */\r\n  public getAll<TResult extends any[] = any[], TKey = any>(\r\n    metadataKey: TKey,\r\n    targets: (Type<any> | Function)[],\r\n  ): TResult {\r\n    return (targets || []).map(target =>\r\n      this.get(metadataKey, target),\r\n    ) as TResult;\r\n  }\r\n\r\n  /**\r\n   * Retrieve metadata for a specified key for a specified set of targets and merge results.\r\n   *\r\n   * @param metadataKey lookup key for metadata to retrieve\r\n   * @param targets context (decorated objects) to retrieve metadata from\r\n   *\r\n   */\r\n  public getAllAndMerge<TResult extends any[] = any[], TKey = any>(\r\n    metadataKey: TKey,\r\n    targets: (Type<any> | Function)[],\r\n  ): TResult {\r\n    const metadataCollection = this.getAll<TResult, TKey>(\r\n      metadataKey,\r\n      targets,\r\n    ).filter(item => item !== undefined);\r\n\r\n    if (isEmpty(metadataCollection)) {\r\n      return metadataCollection as TResult;\r\n    }\r\n    return metadataCollection.reduce((a, b) => {\r\n      if (Array.isArray(a)) {\r\n        return a.concat(b);\r\n      }\r\n      if (isObject(a) && isObject(b)) {\r\n        return {\r\n          ...a,\r\n          ...b,\r\n        };\r\n      }\r\n      return [a, b];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retrieve metadata for a specified key for a specified set of targets and return a first not undefined value.\r\n   *\r\n   * @param metadataKey lookup key for metadata to retrieve\r\n   * @param targets context (decorated objects) to retrieve metadata from\r\n   *\r\n   */\r\n  public getAllAndOverride<TResult = any, TKey = any>(\r\n    metadataKey: TKey,\r\n    targets: (Type<any> | Function)[],\r\n  ): TResult {\r\n    for (const target of targets) {\r\n      const result = this.get(metadataKey, target);\r\n      if (result !== undefined) {\r\n        return result;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"]}