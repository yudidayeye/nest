{"version":3,"file":"abstract-instance-resolver.js","sourceRoot":"D:/04-learn-font/learn-node/nest/packages/core/","sources":["injector/abstract-instance-resolver.ts"],"names":[],"mappings":";;;AAAA,2CAAuD;AAEvD,qDAG8B;AAM9B,MAAsB,wBAAwB;IASlC,IAAI,CACZ,WAA8D,EAC9D,OAA8C;QAE9C,MAAM,mBAAmB,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CACpD,WAAW,EACX,OAAO,CACR,CAAC;QACF,MAAM,aAAa,GAAG,CAAC,EAAE,UAAU,EAAgB,EAAE,EAAE;YACrD,IACE,UAAU,CAAC,KAAK,KAAK,cAAK,CAAC,OAAO;gBAClC,UAAU,CAAC,KAAK,KAAK,cAAK,CAAC,SAAS,EACpC;gBACA,MAAM,IAAI,uCAA0B,CAAC,WAAW,CAAC,CAAC;aACnD;YACD,OAAO,UAAU,CAAC,QAAQ,CAAC;QAC7B,CAAC,CAAC;QACF,IAAI,KAAK,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE;YACtC,OAAO,mBAAmB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;SAC/C;QACD,OAAO,aAAa,CAAC,mBAAmB,CAAC,CAAC;IAC5C,CAAC;IAES,KAAK,CAAC,iBAAiB,CAC/B,WAA8D,EAC9D,aAAqB,EACrB,SAAoB,EACpB,OAA6B;QAE7B,MAAM,mBAAmB,GAAG,OAAO,EAAE,MAAM;YACzC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,WAAW,EAAE;gBACtC,QAAQ,EAAE,aAAa,CAAC,EAAE;gBAC1B,IAAI,EAAE,OAAO,CAAC,IAAI;aACnB,CAAC;YACJ,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,WAAW,EAAE;gBACtC,IAAI,EAAE,OAAO,CAAC,IAAI;aACnB,CAAC,CAAC;QAEP,MAAM,aAAa,GAAG,KAAK,EAAE,YAA0B,EAAE,EAAE;YACzD,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG,YAAY,CAAC;YAChD,IAAI,UAAU,CAAC,sBAAsB,EAAE,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE;gBAClE,OAAO,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;aAC1D;YAED,MAAM,QAAQ,GAAG,UAAU,CAAC,QAAQ,IAAI,EAAE,WAAW,EAAE,WAAW,EAAE,CAAC;YACrE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,CACjD,QAAQ,EACR,UAAU,CAAC,IAAI,EACf,UAAU,EACV,SAAS,EACT,UAAU,CACX,CAAC;YACF,IAAI,CAAC,QAAQ,EAAE;gBACb,MAAM,IAAI,oCAAuB,EAAE,CAAC;aACrC;YACD,OAAO,QAAQ,CAAC;QAClB,CAAC,CAAC;QAEF,IAAI,KAAK,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE;YACtC,OAAO,OAAO,CAAC,GAAG,CAChB,mBAAmB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,CACrE,CAAC;SACH;QACD,OAAO,aAAa,CAAC,mBAAmB,CAAC,CAAC;IAC5C,CAAC;CACF;AA1ED,4DA0EC","sourcesContent":["import { Abstract, Scope, Type } from '@nestjs/common';\r\nimport { GetOrResolveOptions } from '@nestjs/common/interfaces';\r\nimport {\r\n  InvalidClassScopeException,\r\n  UnknownElementException,\r\n} from '../errors/exceptions';\r\nimport { Injector } from './injector';\r\nimport { InstanceLink, InstanceLinksHost } from './instance-links-host';\r\nimport { ContextId } from './instance-wrapper';\r\nimport { Module } from './module';\r\n\r\nexport abstract class AbstractInstanceResolver {\r\n  protected abstract instanceLinksHost: InstanceLinksHost;\r\n  protected abstract injector: Injector;\r\n\r\n  protected abstract get<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n    options?: GetOrResolveOptions,\r\n  ): TResult | Array<TResult>;\r\n\r\n  protected find<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Abstract<TInput> | string | symbol,\r\n    options: { moduleId?: string; each?: boolean },\r\n  ): TResult | Array<TResult> {\r\n    const instanceLinkOrArray = this.instanceLinksHost.get<TResult>(\r\n      typeOrToken,\r\n      options,\r\n    );\r\n    const pluckInstance = ({ wrapperRef }: InstanceLink) => {\r\n      if (\r\n        wrapperRef.scope === Scope.REQUEST ||\r\n        wrapperRef.scope === Scope.TRANSIENT\r\n      ) {\r\n        throw new InvalidClassScopeException(typeOrToken);\r\n      }\r\n      return wrapperRef.instance;\r\n    };\r\n    if (Array.isArray(instanceLinkOrArray)) {\r\n      return instanceLinkOrArray.map(pluckInstance);\r\n    }\r\n    return pluckInstance(instanceLinkOrArray);\r\n  }\r\n\r\n  protected async resolvePerContext<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Abstract<TInput> | string | symbol,\r\n    contextModule: Module,\r\n    contextId: ContextId,\r\n    options?: GetOrResolveOptions,\r\n  ): Promise<TResult | Array<TResult>> {\r\n    const instanceLinkOrArray = options?.strict\r\n      ? this.instanceLinksHost.get(typeOrToken, {\r\n          moduleId: contextModule.id,\r\n          each: options.each,\r\n        })\r\n      : this.instanceLinksHost.get(typeOrToken, {\r\n          each: options.each,\r\n        });\r\n\r\n    const pluckInstance = async (instanceLink: InstanceLink) => {\r\n      const { wrapperRef, collection } = instanceLink;\r\n      if (wrapperRef.isDependencyTreeStatic() && !wrapperRef.isTransient) {\r\n        return this.get(typeOrToken, { strict: options.strict });\r\n      }\r\n\r\n      const ctorHost = wrapperRef.instance || { constructor: typeOrToken };\r\n      const instance = await this.injector.loadPerContext(\r\n        ctorHost,\r\n        wrapperRef.host,\r\n        collection,\r\n        contextId,\r\n        wrapperRef,\r\n      );\r\n      if (!instance) {\r\n        throw new UnknownElementException();\r\n      }\r\n      return instance;\r\n    };\r\n\r\n    if (Array.isArray(instanceLinkOrArray)) {\r\n      return Promise.all(\r\n        instanceLinkOrArray.map(instanceLink => pluckInstance(instanceLink)),\r\n      );\r\n    }\r\n    return pluckInstance(instanceLinkOrArray);\r\n  }\r\n}\r\n"]}