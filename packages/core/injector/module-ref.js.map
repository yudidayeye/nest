{"version":3,"file":"module-ref.js","sourceRoot":"D:/04-learn-font/learn-node/nest/packages/core/","sources":["injector/module-ref.ts"],"names":[],"mappings":";;;AAAA,2CAAkE;AAClE,gEAA2D;AAC3D,sDAAkD;AAClD,6EAAwE;AAExE,yCAAsC;AACtC,+DAA0D;AAC1D,yDAAgE;AAiBhE,MAAsB,SAAU,SAAQ,qDAAwB;IAI9D,IAAc,iBAAiB;QAC7B,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;YAC5B,IAAI,CAAC,kBAAkB,GAAG,IAAI,uCAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SACjE;QACD,OAAO,IAAI,CAAC,kBAAkB,CAAC;IACjC,CAAC;IAED,YAA+B,SAAwB;QACrD,KAAK,EAAE,CAAC;QADqB,cAAS,GAAT,SAAS,CAAe;QAVpC,aAAQ,GAAG,IAAI,mBAAQ,EAAE,CAAC;IAY7C,CAAC;IA+FM,UAAU,CACf,KAAgC;QAEhC,MAAM,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAEzD,IAAI,KAAK,GAAG,cAAK,CAAC,OAAO,CAAC;QAC1B,IAAI,CAAC,UAAU,CAAC,sBAAsB,EAAE,EAAE;YACxC,KAAK,GAAG,cAAK,CAAC,OAAO,CAAC;SACvB;aAAM,IAAI,UAAU,CAAC,WAAW,EAAE;YACjC,KAAK,GAAG,cAAK,CAAC,SAAS,CAAC;SACzB;QACD,OAAO,EAAE,KAAK,EAAE,CAAC;IACnB,CAAC;IAEM,0BAA0B,CAAU,OAAU,EAAE,SAAoB;QACzE,IAAI,CAAC,SAAS,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;IAC7D,CAAC;IAES,KAAK,CAAC,gBAAgB,CAC9B,IAAa,EACb,SAAiB;QAEjB,MAAM,OAAO,GAAG,IAAI,kCAAe,CAAC;YAClC,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,IAAI;YACvB,QAAQ,EAAE,IAAI;YACd,UAAU,EAAE,KAAK;YACjB,KAAK,EAAE,IAAA,+BAAa,EAAC,IAAI,CAAC;YAC1B,OAAO,EAAE,IAAA,sBAAS,EAAC,IAAI,CAAC;YACxB,IAAI,EAAE,SAAS;SAChB,CAAC,CAAC;QACH,OAAO,IAAI,OAAO,CAAI,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE;YAC9C,IAAI;gBACF,MAAM,QAAQ,GAAG,KAAK,EAAE,SAAgB,EAAE,EAAE;oBAC1C,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CACtD,OAAO,EACP,SAAS,CACV,CAAC;oBACF,MAAM,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACxC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;oBACpD,OAAO,CAAC,QAAQ,CAAC,CAAC;gBACpB,CAAC,CAAC;gBACF,MAAM,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAC1C,OAAO,EACP,SAAS,EACT,SAAS,EACT,QAAQ,CACT,CAAC;aACH;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,CAAC,GAAG,CAAC,CAAC;aACb;QACH,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAhKD,8BAgKC","sourcesContent":["import { IntrospectionResult, Scope, Type } from '@nestjs/common';\r\nimport { getClassScope } from '../helpers/get-class-scope';\r\nimport { isDurable } from '../helpers/is-durable';\r\nimport { AbstractInstanceResolver } from './abstract-instance-resolver';\r\nimport { NestContainer } from './container';\r\nimport { Injector } from './injector';\r\nimport { InstanceLinksHost } from './instance-links-host';\r\nimport { ContextId, InstanceWrapper } from './instance-wrapper';\r\nimport { Module } from './module';\r\n\r\nexport interface ModuleRefGetOrResolveOpts {\r\n  /**\r\n   * If enabled, lookup will only be performed in the host module.\r\n   * @default true\r\n   */\r\n  strict?: boolean;\r\n  /**\r\n   * If enabled, instead of returning a first instance registered under a given token,\r\n   * a list of instances will be returned.\r\n   * @default false\r\n   */\r\n  each?: boolean;\r\n}\r\n\r\nexport abstract class ModuleRef extends AbstractInstanceResolver {\r\n  protected readonly injector = new Injector();\r\n  private _instanceLinksHost: InstanceLinksHost;\r\n\r\n  protected get instanceLinksHost() {\r\n    if (!this._instanceLinksHost) {\r\n      this._instanceLinksHost = new InstanceLinksHost(this.container);\r\n    }\r\n    return this._instanceLinksHost;\r\n  }\r\n\r\n  constructor(protected readonly container: NestContainer) {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Retrieves an instance of either injectable or controller, otherwise, throws exception.\r\n   * @returns {TResult}\r\n   */\r\n  abstract get<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n  ): TResult;\r\n  /**\r\n   * Retrieves an instance of either injectable or controller, otherwise, throws exception.\r\n   * @returns {TResult}\r\n   */\r\n  abstract get<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n    options: {\r\n      /**\r\n       * If enabled, lookup will only be performed in the host module.\r\n       * @default true\r\n       */\r\n      strict?: boolean;\r\n      /** This indicates that only the first instance registered will be returned. */\r\n      each?: undefined | false;\r\n    },\r\n  ): TResult;\r\n  /**\r\n   * Retrieves a list of instances of either injectables or controllers, otherwise, throws exception.\r\n   * @returns {Array<TResult>}\r\n   */\r\n  abstract get<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n    options: {\r\n      /**\r\n       * If enabled, lookup will only be performed in the host module.\r\n       * @default true\r\n       */\r\n      strict?: boolean;\r\n      /** This indicates that a list of instances will be returned. */\r\n      each: true;\r\n    },\r\n  ): Array<TResult>;\r\n  /**\r\n   * Retrieves an instance (or a list of instances) of either injectable or controller, otherwise, throws exception.\r\n   * @returns {TResult | Array<TResult>}\r\n   */\r\n  abstract get<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n    options?: ModuleRefGetOrResolveOpts,\r\n  ): TResult | Array<TResult>;\r\n\r\n  /**\r\n   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.\r\n   * @returns {Array<TResult>}\r\n   */\r\n  abstract resolve<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n  ): Promise<TResult>;\r\n  /**\r\n   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.\r\n   * @returns {Array<TResult>}\r\n   */\r\n  abstract resolve<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n    contextId?: { id: number },\r\n  ): Promise<TResult>;\r\n  /**\r\n   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.\r\n   * @returns {Array<TResult>}\r\n   */\r\n  abstract resolve<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n    contextId?: { id: number },\r\n    options?: { strict?: boolean; each?: undefined | false },\r\n  ): Promise<TResult>;\r\n  /**\r\n   * Resolves transient or request-scoped instances of either injectables or controllers, otherwise, throws exception.\r\n   * @returns {Array<TResult>}\r\n   */\r\n  abstract resolve<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n    contextId?: { id: number },\r\n    options?: { strict?: boolean; each: true },\r\n  ): Promise<Array<TResult>>;\r\n  /**\r\n   * Resolves transient or request-scoped instance (or a list of instances) of either injectable or controller, otherwise, throws exception.\r\n   * @returns {Promise<TResult | Array<TResult>>}\r\n   */\r\n  abstract resolve<TInput = any, TResult = TInput>(\r\n    typeOrToken: Type<TInput> | Function | string | symbol,\r\n    contextId?: { id: number },\r\n    options?: ModuleRefGetOrResolveOpts,\r\n  ): Promise<TResult | Array<TResult>>;\r\n\r\n  public abstract create<T = any>(type: Type<T>): Promise<T>;\r\n\r\n  public introspect<T = any>(\r\n    token: Type<T> | string | symbol,\r\n  ): IntrospectionResult {\r\n    const { wrapperRef } = this.instanceLinksHost.get(token);\r\n\r\n    let scope = Scope.DEFAULT;\r\n    if (!wrapperRef.isDependencyTreeStatic()) {\r\n      scope = Scope.REQUEST;\r\n    } else if (wrapperRef.isTransient) {\r\n      scope = Scope.TRANSIENT;\r\n    }\r\n    return { scope };\r\n  }\r\n\r\n  public registerRequestByContextId<T = any>(request: T, contextId: ContextId) {\r\n    this.container.registerRequestProvider(request, contextId);\r\n  }\r\n\r\n  protected async instantiateClass<T = any>(\r\n    type: Type<T>,\r\n    moduleRef: Module,\r\n  ): Promise<T> {\r\n    const wrapper = new InstanceWrapper({\r\n      name: type && type.name,\r\n      metatype: type,\r\n      isResolved: false,\r\n      scope: getClassScope(type),\r\n      durable: isDurable(type),\r\n      host: moduleRef,\r\n    });\r\n    return new Promise<T>(async (resolve, reject) => {\r\n      try {\r\n        const callback = async (instances: any[]) => {\r\n          const properties = await this.injector.resolveProperties(\r\n            wrapper,\r\n            moduleRef,\r\n          );\r\n          const instance = new type(...instances);\r\n          this.injector.applyProperties(instance, properties);\r\n          resolve(instance);\r\n        };\r\n        await this.injector.resolveConstructorParams<T>(\r\n          wrapper,\r\n          moduleRef,\r\n          undefined,\r\n          callback,\r\n        );\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  }\r\n}\r\n"]}