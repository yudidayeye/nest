{"version":3,"file":"context-id-factory.js","sourceRoot":"D:/04-learn-font/learn-node/nest/packages/core/","sources":["helpers/context-id-factory.ts"],"names":[],"mappings":";;;AAAA,oEAA6D;AAE7D,2EAAyE;AAEzE,SAAgB,eAAe;IAC7B;;;;;;;OAOG;IACH,OAAO,EAAE,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC;AAC/B,CAAC;AAVD,0CAUC;AA4BD,MAAa,gBAAgB;IAG3B;;OAEG;IACI,MAAM,CAAC,MAAM;QAClB,OAAO,eAAe,EAAE,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,YAAY,CACxB,OAAU,EACV,iBAA2B,CAAC,KAAK,CAAC;QAElC,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,gBAAgB,CAAC,MAAM,EAAE,CAAC;SAClC;QACD,IAAI,OAAO,CAAC,sCAAyB,CAAC,EAAE;YACtC,OAAO,OAAO,CAAC,sCAAyB,CAAC,CAAC;SAC3C;QACD,KAAK,MAAM,GAAG,IAAI,cAAc,EAAE;YAChC,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,sCAAkB,CAAC,EAAE;gBACtC,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,sCAAkB,CAAC,CAAC;aACzC;SACF;QACD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClB,OAAO,gBAAgB,CAAC,MAAM,EAAE,CAAC;SAClC;QACD,MAAM,SAAS,GAAG,eAAe,EAAE,CAAC;QACpC,MAAM,wBAAwB,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAC1E,IAAI,IAAI,CAAC,8BAA8B,CAAC,wBAAwB,CAAC,EAAE;YACjE,SAAS,CAAC,SAAS,GAAG,wBAAwB,CAAC,OAAO,CAAC;YACvD,SAAS,CAAC,OAAO,GAAG,wBAAwB,CAAC,OAAO,CAAC;SACtD;aAAM;YACL,SAAS,CAAC,SAAS,GAAG,wBAAwB,CAAC;SAChD;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,KAAK,CAAC,QAA2B;QAC7C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAEO,MAAM,CAAC,8BAA8B,CAC3C,oBAA6D;QAE7D,OAAO,IAAA,uBAAQ,EAAC,oBAAoB,CAAC,CAAC;IACxC,CAAC;CACF;AAzDD,4CAyDC","sourcesContent":["import { isObject } from '@nestjs/common/utils/shared.utils';\r\nimport { ContextId, HostComponentInfo } from '../injector/instance-wrapper';\r\nimport { REQUEST_CONTEXT_ID } from '../router/request/request-constants';\r\n\r\nexport function createContextId(): ContextId {\r\n  /**\r\n   * We are generating random identifier to track asynchronous\r\n   * execution context. An identifier does not have to be neither unique\r\n   * nor unpredictable because WeakMap uses objects as keys (reference comparison).\r\n   * Thus, even though identifier number might be equal, WeakMap would properly\r\n   * associate asynchronous context with its internal map values using object reference.\r\n   * Object is automatically removed once request has been processed (closure).\r\n   */\r\n  return { id: Math.random() };\r\n}\r\n\r\nexport type ContextIdResolverFn = (info: HostComponentInfo) => ContextId;\r\n\r\nexport interface ContextIdResolver {\r\n  /**\r\n   * Payload associated with the custom context id\r\n   */\r\n  payload: unknown;\r\n  /**\r\n   * A context id resolver function\r\n   */\r\n  resolve: ContextIdResolverFn;\r\n}\r\n\r\nexport interface ContextIdStrategy<T = any> {\r\n  /**\r\n   * Allows to attach a parent context id to the existing child context id.\r\n   * This lets you construct durable DI sub-trees that can be shared between contexts.\r\n   * @param contextId auto-generated child context id\r\n   * @param request request object\r\n   */\r\n  attach(\r\n    contextId: ContextId,\r\n    request: T,\r\n  ): ContextIdResolverFn | ContextIdResolver | undefined;\r\n}\r\n\r\nexport class ContextIdFactory {\r\n  private static strategy?: ContextIdStrategy;\r\n\r\n  /**\r\n   * Generates a context identifier based on the request object.\r\n   */\r\n  public static create(): ContextId {\r\n    return createContextId();\r\n  }\r\n\r\n  /**\r\n   * Generates a random identifier to track asynchronous execution context.\r\n   * @param request request object\r\n   */\r\n  public static getByRequest<T extends Record<any, any> = any>(\r\n    request: T,\r\n    propsToInspect: string[] = ['raw'],\r\n  ): ContextId {\r\n    if (!request) {\r\n      return ContextIdFactory.create();\r\n    }\r\n    if (request[REQUEST_CONTEXT_ID as any]) {\r\n      return request[REQUEST_CONTEXT_ID as any];\r\n    }\r\n    for (const key of propsToInspect) {\r\n      if (request[key]?.[REQUEST_CONTEXT_ID]) {\r\n        return request[key][REQUEST_CONTEXT_ID];\r\n      }\r\n    }\r\n    if (!this.strategy) {\r\n      return ContextIdFactory.create();\r\n    }\r\n    const contextId = createContextId();\r\n    const resolverObjectOrFunction = this.strategy.attach(contextId, request);\r\n    if (this.isContextIdResolverWithPayload(resolverObjectOrFunction)) {\r\n      contextId.getParent = resolverObjectOrFunction.resolve;\r\n      contextId.payload = resolverObjectOrFunction.payload;\r\n    } else {\r\n      contextId.getParent = resolverObjectOrFunction;\r\n    }\r\n    return contextId;\r\n  }\r\n\r\n  /**\r\n   * Registers a custom context id strategy that lets you attach\r\n   * a parent context id to the existing context id object.\r\n   * @param strategy strategy instance\r\n   */\r\n  public static apply(strategy: ContextIdStrategy) {\r\n    this.strategy = strategy;\r\n  }\r\n\r\n  private static isContextIdResolverWithPayload(\r\n    resolverOrResolverFn: ContextIdResolver | ContextIdResolverFn,\r\n  ): resolverOrResolverFn is ContextIdResolver {\r\n    return isObject(resolverOrResolverFn);\r\n  }\r\n}\r\n"]}