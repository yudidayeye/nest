{"version":3,"file":"configurable-module.builder.js","sourceRoot":"","sources":["configurable-module.builder.ts"],"names":[],"mappings":"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","sourcesContent":["import { DynamicModule, Provider } from '../interfaces';\r\nimport { Logger } from '../services/logger.service';\r\nimport { randomStringGenerator } from '../utils/random-string-generator.util';\r\nimport {\r\n  ASYNC_METHOD_SUFFIX,\r\n  CONFIGURABLE_MODULE_ID,\r\n  DEFAULT_FACTORY_CLASS_METHOD_KEY,\r\n  DEFAULT_METHOD_KEY,\r\n} from './constants';\r\nimport {\r\n  ConfigurableModuleAsyncOptions,\r\n  ConfigurableModuleCls,\r\n  ConfigurableModuleHost,\r\n  ConfigurableModuleOptionsFactory,\r\n} from './interfaces';\r\nimport { generateOptionsInjectionToken, getInjectionProviders } from './utils';\r\n\r\n/**\r\n * @publicApi\r\n */\r\nexport interface ConfigurableModuleBuilderOptions {\r\n  /**\r\n   * Specified what injection token should be used for the module options provider.\r\n   * By default, an auto-generated UUID will be used.\r\n   */\r\n  optionsInjectionToken?: string | symbol;\r\n  /**\r\n   * By default, an UUID will be used as a module options provider token.\r\n   * Explicitly specifying the \"moduleName\" will instruct the \"ConfigurableModuleBuilder\"\r\n   * to use a more descriptive provider token.\r\n   *\r\n   * For example, if `moduleName: \"Cache\"` then auto-generated provider token will be \"CACHE_MODULE_OPTIONS\".\r\n   */\r\n  moduleName?: string;\r\n  /**\r\n   * Indicates whether module should always be \"transient\", meaning,\r\n   * every time you call the static method to construct a dynamic module,\r\n   * regardless of what arguments you pass in, a new \"unique\" module will be created.\r\n   *\r\n   * @default false\r\n   */\r\n  alwaysTransient?: boolean;\r\n}\r\n\r\n/**\r\n * Factory that lets you create configurable modules and\r\n * provides a way to reduce the majority of dynamic module boilerplate.\r\n *\r\n * @publicApi\r\n */\r\nexport class ConfigurableModuleBuilder<\r\n  ModuleOptions,\r\n  StaticMethodKey extends string = typeof DEFAULT_METHOD_KEY,\r\n  FactoryClassMethodKey extends string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,\r\n  ExtraModuleDefinitionOptions = {},\r\n> {\r\n  protected staticMethodKey: StaticMethodKey;\r\n  protected factoryClassMethodKey: FactoryClassMethodKey;\r\n  protected extras: ExtraModuleDefinitionOptions;\r\n  protected transformModuleDefinition: (\r\n    definition: DynamicModule,\r\n    extraOptions: ExtraModuleDefinitionOptions,\r\n  ) => DynamicModule;\r\n\r\n  protected readonly logger = new Logger(ConfigurableModuleBuilder.name);\r\n\r\n  constructor(\r\n    protected readonly options: ConfigurableModuleBuilderOptions = {},\r\n    parentBuilder?: ConfigurableModuleBuilder<ModuleOptions>,\r\n  ) {\r\n    if (parentBuilder) {\r\n      this.staticMethodKey = parentBuilder.staticMethodKey as StaticMethodKey;\r\n      this.factoryClassMethodKey =\r\n        parentBuilder.factoryClassMethodKey as FactoryClassMethodKey;\r\n      this.transformModuleDefinition = parentBuilder.transformModuleDefinition;\r\n      this.extras = parentBuilder.extras as ExtraModuleDefinitionOptions;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers the \"extras\" object (a set of extra options that can be used to modify the dynamic module definition).\r\n   * Values you specify within the \"extras\" object will be used as default values (that can be overridden by module consumers).\r\n   *\r\n   * This method also applies the so-called \"module definition transform function\" that takes the auto-generated\r\n   * dynamic module object (\"DynamicModule\") and the actual consumer \"extras\" object as input parameters.\r\n   * The \"extras\" object consists of values explicitly specified by module consumers and default values.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>\r\n   *    ({ ...definition, global: extras.isGlobal })\r\n   * )\r\n   * ```\r\n   */\r\n  setExtras<ExtraModuleDefinitionOptions>(\r\n    extras: ExtraModuleDefinitionOptions,\r\n    transformDefinition: (\r\n      definition: DynamicModule,\r\n      extras: ExtraModuleDefinitionOptions,\r\n    ) => DynamicModule = def => def,\r\n  ) {\r\n    const builder = new ConfigurableModuleBuilder<\r\n      ModuleOptions,\r\n      StaticMethodKey,\r\n      FactoryClassMethodKey,\r\n      ExtraModuleDefinitionOptions\r\n    >(this.options, this as any);\r\n    builder.extras = extras;\r\n    builder.transformModuleDefinition = transformDefinition;\r\n    return builder;\r\n  }\r\n\r\n  /**\r\n   * Dynamic modules must expose public static methods that let you pass in\r\n   * configuration parameters (control the module's behavior from the outside).\r\n   * Some frequently used names that you may have seen in other modules are:\r\n   * \"forRoot\", \"forFeature\", \"register\", \"configure\".\r\n   *\r\n   * This method \"setClassMethodName\" lets you specify the name of the\r\n   * method that will be auto-generated.\r\n   *\r\n   * @param key name of the method\r\n   */\r\n  setClassMethodName<StaticMethodKey extends string>(key: StaticMethodKey) {\r\n    const builder = new ConfigurableModuleBuilder<\r\n      ModuleOptions,\r\n      StaticMethodKey,\r\n      FactoryClassMethodKey,\r\n      ExtraModuleDefinitionOptions\r\n    >(this.options, this as any);\r\n    builder.staticMethodKey = key;\r\n    return builder;\r\n  }\r\n\r\n  /**\r\n   * Asynchronously configured modules (that rely on other modules, i.e. \"ConfigModule\")\r\n   * let you pass the configuration factory class that will be registered and instantiated as a provider.\r\n   * This provider then will be used to retrieve the module's configuration. To provide the configuration,\r\n   * the corresponding factory method must be implemented.\r\n   *\r\n   * This method (\"setFactoryMethodName\") lets you control what method name will have to be\r\n   * implemented by the config factory (default is \"create\").\r\n   *\r\n   * @param key name of the method\r\n   */\r\n  setFactoryMethodName<FactoryClassMethodKey extends string>(\r\n    key: FactoryClassMethodKey,\r\n  ) {\r\n    const builder = new ConfigurableModuleBuilder<\r\n      ModuleOptions,\r\n      StaticMethodKey,\r\n      FactoryClassMethodKey,\r\n      ExtraModuleDefinitionOptions\r\n    >(this.options, this as any);\r\n    builder.factoryClassMethodKey = key;\r\n    return builder;\r\n  }\r\n\r\n  /**\r\n   * Returns an object consisting of multiple properties that lets you\r\n   * easily construct dynamic configurable modules. See \"ConfigurableModuleHost\" interface for more details.\r\n   */\r\n  build(): ConfigurableModuleHost<\r\n    ModuleOptions,\r\n    StaticMethodKey,\r\n    FactoryClassMethodKey,\r\n    ExtraModuleDefinitionOptions\r\n  > {\r\n    this.staticMethodKey ??= DEFAULT_METHOD_KEY as StaticMethodKey;\r\n    this.factoryClassMethodKey ??=\r\n      DEFAULT_FACTORY_CLASS_METHOD_KEY as FactoryClassMethodKey;\r\n    this.options.optionsInjectionToken ??= this.options.moduleName\r\n      ? this.constructInjectionTokenString()\r\n      : generateOptionsInjectionToken();\r\n    this.transformModuleDefinition ??= definition => definition;\r\n\r\n    return {\r\n      ConfigurableModuleClass:\r\n        this.createConfigurableModuleCls<ModuleOptions>(),\r\n      MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,\r\n      ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),\r\n      OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE'),\r\n    };\r\n  }\r\n\r\n  private constructInjectionTokenString(): string {\r\n    const moduleNameInSnakeCase = this.options.moduleName\r\n      .trim()\r\n      .split(/(?=[A-Z])/)\r\n      .join('_')\r\n      .toUpperCase();\r\n    return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;\r\n  }\r\n\r\n  private createConfigurableModuleCls<ModuleOptions>(): ConfigurableModuleCls<\r\n    ModuleOptions,\r\n    StaticMethodKey,\r\n    FactoryClassMethodKey\r\n  > {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const self = this;\r\n    const asyncMethodKey = this.staticMethodKey + ASYNC_METHOD_SUFFIX;\r\n\r\n    class InternalModuleClass {\r\n      static [self.staticMethodKey](\r\n        options: ModuleOptions & ExtraModuleDefinitionOptions,\r\n      ): DynamicModule {\r\n        const providers: Array<Provider> = [\r\n          {\r\n            provide: self.options.optionsInjectionToken,\r\n            useValue: this.omitExtras(options, self.extras),\r\n          },\r\n        ];\r\n        if (self.options.alwaysTransient) {\r\n          providers.push({\r\n            provide: CONFIGURABLE_MODULE_ID,\r\n            useValue: randomStringGenerator(),\r\n          });\r\n        }\r\n        return self.transformModuleDefinition(\r\n          {\r\n            module: this,\r\n            providers,\r\n          },\r\n          {\r\n            ...self.extras,\r\n            ...options,\r\n          },\r\n        );\r\n      }\r\n\r\n      static [asyncMethodKey](\r\n        options: ConfigurableModuleAsyncOptions<ModuleOptions> &\r\n          ExtraModuleDefinitionOptions,\r\n      ): DynamicModule {\r\n        const providers = this.createAsyncProviders(options);\r\n        if (self.options.alwaysTransient) {\r\n          providers.push({\r\n            provide: CONFIGURABLE_MODULE_ID,\r\n            useValue: randomStringGenerator(),\r\n          });\r\n        }\r\n        return self.transformModuleDefinition(\r\n          {\r\n            module: this,\r\n            imports: options.imports || [],\r\n            providers,\r\n          },\r\n          {\r\n            ...self.extras,\r\n            ...options,\r\n          },\r\n        );\r\n      }\r\n\r\n      private static omitExtras(\r\n        input: ModuleOptions & ExtraModuleDefinitionOptions,\r\n        extras: ExtraModuleDefinitionOptions | undefined,\r\n      ): ModuleOptions {\r\n        if (!extras) {\r\n          return input;\r\n        }\r\n        const moduleOptions = {};\r\n        const extrasKeys = Object.keys(extras);\r\n\r\n        Object.keys(input)\r\n          .filter(key => !extrasKeys.includes(key))\r\n          .forEach(key => {\r\n            moduleOptions[key] = input[key];\r\n          });\r\n        return moduleOptions as ModuleOptions;\r\n      }\r\n\r\n      private static createAsyncProviders(\r\n        options: ConfigurableModuleAsyncOptions<ModuleOptions>,\r\n      ): Provider[] {\r\n        if (options.useExisting || options.useFactory) {\r\n          if (options.inject && options.provideInjectionTokensFrom) {\r\n            return [\r\n              this.createAsyncOptionsProvider(options),\r\n              ...getInjectionProviders(\r\n                options.provideInjectionTokensFrom,\r\n                options.inject,\r\n              ),\r\n            ];\r\n          }\r\n          return [this.createAsyncOptionsProvider(options)];\r\n        }\r\n        return [\r\n          this.createAsyncOptionsProvider(options),\r\n          {\r\n            provide: options.useClass,\r\n            useClass: options.useClass,\r\n          },\r\n        ];\r\n      }\r\n\r\n      private static createAsyncOptionsProvider(\r\n        options: ConfigurableModuleAsyncOptions<ModuleOptions>,\r\n      ): Provider {\r\n        if (options.useFactory) {\r\n          return {\r\n            provide: self.options.optionsInjectionToken,\r\n            useFactory: options.useFactory,\r\n            inject: options.inject || [],\r\n          };\r\n        }\r\n        return {\r\n          provide: self.options.optionsInjectionToken,\r\n          useFactory: async (\r\n            optionsFactory: ConfigurableModuleOptionsFactory<\r\n              ModuleOptions,\r\n              FactoryClassMethodKey\r\n            >,\r\n          ) =>\r\n            await optionsFactory[\r\n              self.factoryClassMethodKey as keyof typeof optionsFactory\r\n            ](),\r\n          inject: [options.useExisting || options.useClass],\r\n        };\r\n      }\r\n    }\r\n    return InternalModuleClass as unknown as ConfigurableModuleCls<\r\n      ModuleOptions,\r\n      StaticMethodKey,\r\n      FactoryClassMethodKey\r\n    >;\r\n  }\r\n\r\n  private createTypeProxy(\r\n    typeName: 'OPTIONS_TYPE' | 'ASYNC_OPTIONS_TYPE' | 'OptionsFactoryInterface',\r\n  ) {\r\n    const proxy = new Proxy(\r\n      {},\r\n      {\r\n        get: () => {\r\n          throw new Error(\r\n            `\"${typeName}\" is not supposed to be used as a value.`,\r\n          );\r\n        },\r\n      },\r\n    );\r\n    return proxy as any;\r\n  }\r\n}\r\n"]}