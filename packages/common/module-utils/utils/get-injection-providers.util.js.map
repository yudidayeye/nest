{"version":3,"file":"get-injection-providers.util.js","sourceRoot":"","sources":["get-injection-providers.util.ts"],"names":[],"mappings":";;;AAOA;;;;;GAKG;AACH,SAAS,2BAA2B,CAClC,CAA6C;IAE7C,OAAO,CAAC,CAAC,CAAE,CAAS,EAAE,KAAK,IAAI,CAAE,CAAS,EAAE,SAAS,CAAC,CAAC;AACzD,CAAC;AAED,MAAM,iBAAiB,GAAG,CAAC,CAA6C,EAAE,EAAE,CAC1E,2BAA2B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAE/C;;;;;GAKG;AACH,SAAgB,qBAAqB,CACnC,SAAqB,EACrB,MAAiC;IAEjC,MAAM,MAAM,GAAe,EAAE,CAAC;IAC9B,IAAI,MAAM,GAAqB,MAAM,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;IAC7D,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACxB,MAAM,KAAK,GAAG,CAAC,SAAS,IAAI,EAAE,CAAC,CAAC,MAAM,CACpC,CAAC,CAAC,EAAE,CACF,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,+CAA+C;YACtE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAQ,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAE,CAAS,EAAE,OAAO,CAAC,CAAC,CACtE,CAAC;QACF,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;QACtB,wDAAwD;QACxD,MAAM,GAAG,KAAK;aACX,MAAM,CAAC,CAAC,CAAC,EAAE,CAAE,CAAS,EAAE,MAAM,CAAC;aAC/B,GAAG,CAAC,CAAC,CAAC,EAAE,CAAE,CAAqB,CAAC,MAAM,CAAC;aACvC,IAAI,EAAE;aACN,GAAG,CAAC,iBAAiB,CAAC,CAAC;KAC3B;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AArBD,sDAqBC","sourcesContent":["import {\r\n  InjectionToken,\r\n  Provider,\r\n  FactoryProvider,\r\n  OptionalFactoryDependency,\r\n} from '../../interfaces';\r\n\r\n/**\r\n * check if x is OptionalFactoryDependency, based on prototype presence\r\n * (to avoid classes with a static 'token' field)\r\n * @param x\r\n * @returns x is OptionalFactoryDependency\r\n */\r\nfunction isOptionalFactoryDependency(\r\n  x: InjectionToken | OptionalFactoryDependency,\r\n): x is OptionalFactoryDependency {\r\n  return !!((x as any)?.token && !(x as any)?.prototype);\r\n}\r\n\r\nconst mapInjectToTokens = (t: InjectionToken | OptionalFactoryDependency) =>\r\n  isOptionalFactoryDependency(t) ? t.token : t;\r\n\r\n/**\r\n *\r\n * @param providers List of a module's providers\r\n * @param tokens Injection tokens needed for a useFactory function (usually the module's options' token)\r\n * @returns All the providers needed for the tokens' injection (searched recursively)\r\n */\r\nexport function getInjectionProviders(\r\n  providers: Provider[],\r\n  tokens: FactoryProvider['inject'],\r\n): Provider[] {\r\n  const result: Provider[] = [];\r\n  let search: InjectionToken[] = tokens.map(mapInjectToTokens);\r\n  while (search.length > 0) {\r\n    const match = (providers ?? []).filter(\r\n      p =>\r\n        !result.includes(p) && // this prevents circular loops and duplication\r\n        (search.includes(p as any) || search.includes((p as any)?.provide)),\r\n    );\r\n    result.push(...match);\r\n    // get injection tokens of the matched providers, if any\r\n    search = match\r\n      .filter(p => (p as any)?.inject)\r\n      .map(p => (p as FactoryProvider).inject)\r\n      .flat()\r\n      .map(mapInjectToTokens);\r\n  }\r\n  return result;\r\n}\r\n"]}