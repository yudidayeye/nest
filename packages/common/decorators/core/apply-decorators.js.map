{"version":3,"file":"apply-decorators.js","sourceRoot":"","sources":["apply-decorators.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;GAQG;AACH,SAAgB,eAAe,CAC7B,GAAG,UAAuE;IAE1E,OAAO,CACL,MAA0B,EAC1B,WAA6B,EAC7B,UAAuC,EACvC,EAAE;QACF,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE;YAClC,IAAI,MAAM,YAAY,QAAQ,IAAI,CAAC,UAAU,EAAE;gBAC5C,SAA4B,CAAC,MAAM,CAAC,CAAC;gBACtC,SAAS;aACV;YACA,SAAiD,CAChD,MAAM,EACN,WAAW,EACX,UAAU,CACX,CAAC;SACH;IACH,CAAC,CAAC;AACJ,CAAC;AApBD,0CAoBC","sourcesContent":["/**\r\n * Function that returns a new decorator that applies all decorators provided by param\r\n *\r\n * Useful to build new decorators (or a decorator factory) encapsulating multiple decorators related with the same feature\r\n *\r\n * @param decorators one or more decorators (e.g., `ApplyGuard(...)`)\r\n *\r\n * @publicApi\r\n */\r\nexport function applyDecorators(\r\n  ...decorators: Array<ClassDecorator | MethodDecorator | PropertyDecorator>\r\n) {\r\n  return <TFunction extends Function, Y>(\r\n    target: TFunction | object,\r\n    propertyKey?: string | symbol,\r\n    descriptor?: TypedPropertyDescriptor<Y>,\r\n  ) => {\r\n    for (const decorator of decorators) {\r\n      if (target instanceof Function && !descriptor) {\r\n        (decorator as ClassDecorator)(target);\r\n        continue;\r\n      }\r\n      (decorator as MethodDecorator | PropertyDecorator)(\r\n        target,\r\n        propertyKey,\r\n        descriptor,\r\n      );\r\n    }\r\n  };\r\n}\r\n"]}