{"version":3,"file":"https-options.interface.js","sourceRoot":"","sources":["https-options.interface.ts"],"names":[],"mappings":"","sourcesContent":["/**\r\n * Interface describing Https Options that can be set.\r\n *\r\n * @see https://nodejs.org/api/tls.html\r\n *\r\n * @publicApi\r\n */\r\nexport interface HttpsOptions {\r\n  /**\r\n   * PFX or PKCS12 encoded private key and certificate chain. pfx is an alternative\r\n   * to providing key and cert individually. PFX is usually encrypted, if it is,\r\n   * passphrase will be used to decrypt it. Multiple PFX can be provided either\r\n   * as an array of unencrypted PFX buffers, or an array of objects in the form\r\n   * {buf: <string|buffer>[, passphrase: <string>]}. The object form can only\r\n   * occur in an array. object.passphrase is optional. Encrypted PFX will be decrypted\r\n   * with object.passphrase if provided, or options.passphrase if it is not.\r\n   */\r\n  pfx?: any;\r\n  /**\r\n   * Private keys in PEM format. PEM allows the option of private keys being encrypted.\r\n   * Encrypted keys will be decrypted with options.passphrase. Multiple keys using\r\n   * different algorithms can be provided either as an array of unencrypted key\r\n   * strings or buffers, or an array of objects in the form {pem: <string|buffer>[, passphrase: <string>]}.\r\n   * The object form can only occur in an array. object.passphrase is optional.\r\n   * Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase\r\n   * if it is not\r\n   */\r\n  key?: any;\r\n  /**\r\n   * Shared passphrase used for a single private key and/or a PFX.\r\n   */\r\n  passphrase?: string;\r\n  /**\r\n   * Cert chains in PEM format. One cert chain should be provided per private key.\r\n   * Each cert chain should consist of the PEM formatted certificate for a provided\r\n   * private key, followed by the PEM formatted intermediate certificates (if any),\r\n   * in order, and not including the root CA (the root CA must be pre-known to the\r\n   * peer, see ca). When providing multiple cert chains, they do not have to be\r\n   * in the same order as their private keys in key. If the intermediate certificates\r\n   * are not provided, the peer will not be able to validate the certificate, and\r\n   * the handshake will fail.\r\n   */\r\n  cert?: any;\r\n  /**\r\n   * Optionally override the trusted CA certificates. Default is to trust the well-known\r\n   * CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are\r\n   * explicitly specified using this option. The value can be a string or Buffer,\r\n   * or an Array of strings and/or Buffers. Any string or Buffer can contain multiple\r\n   * PEM CAs concatenated together. The peer's certificate must be chainable to\r\n   * a CA trusted by the server for the connection to be authenticated. When using\r\n   * certificates that are not chainable to a well-known CA, the certificate's CA\r\n   * must be explicitly specified as a trusted or the connection will fail to authenticate.\r\n   * If the peer uses a certificate that doesn't match or chain to one of the default\r\n   * CAs, use the ca option to provide a CA certificate that the peer's certificate\r\n   * can match or chain to. For self-signed certificates, the certificate is its\r\n   * own CA, and must be provided. For PEM encoded certificates, supported types\r\n   * are \"TRUSTED CERTIFICATE\", \"X509 CERTIFICATE\", and \"CERTIFICATE\". See also tls.rootCertificates.\r\n   */\r\n  ca?: any;\r\n  /**\r\n   * PEM formatted CRLs (Certificate Revocation Lists).\r\n   */\r\n  crl?: any;\r\n  /**\r\n   * Cipher suite specification, replacing the default. For more information, see\r\n   * modifying the default cipher suite. Permitted ciphers can be obtained via tls.getCiphers().\r\n   * Cipher names must be uppercased in order for OpenSSL to accept them.\r\n   */\r\n  ciphers?: string;\r\n  /**\r\n   * Attempt to use the server's cipher suite preferences instead of the client's.\r\n   * When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be set in secureOptions,\r\n   * see OpenSSL Options for more information.\r\n   */\r\n  honorCipherOrder?: boolean;\r\n  /**\r\n   * If true the server will request a certificate from clients that connect and\r\n   * attempt to verify that certificate. Default: false.\r\n   */\r\n  requestCert?: boolean;\r\n  /**\r\n   * If not false the server will reject any connection which is not authorized\r\n   * with the list of supplied CAs. This option only has an effect if requestCert is true. Default: true\r\n   */\r\n  rejectUnauthorized?: boolean;\r\n  /**\r\n   * An array or Buffer of possible NPN protocols. (Protocols should be ordered\r\n   * by their priority).\r\n   */\r\n  NPNProtocols?: any;\r\n  /**\r\n   * A function that will be called if the client supports SNI TLS extension. Two\r\n   * arguments will be passed when called: servername and cb. SNICallback should\r\n   * invoke cb(null, ctx), where ctx is a SecureContext instance. (tls.createSecureContext(...)\r\n   * can be used to get a proper SecureContext.) If SNICallback wasn't provided\r\n   * the default callback with high-level API will be used.\r\n   */\r\n  SNICallback?: (servername: string, cb: (err: Error, ctx: any) => any) => any;\r\n}\r\n"]}