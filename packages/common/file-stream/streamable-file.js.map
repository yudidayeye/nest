{"version":3,"file":"streamable-file.js","sourceRoot":"","sources":["streamable-file.ts"],"names":[],"mappings":";;;AAAA,mCAAkC;AAClC,+BAA6B;AAC7B,oCAAsC;AACtC,wDAAmD;AAGnD;;;;GAIG;AACH,MAAa,cAAc;IAqBzB,YACE,kBAAyC,EAChC,UAAiC,EAAE;QAAnC,YAAO,GAAP,OAAO,CAA4B;QApBpC,gBAAW,GAGT,CAAC,GAAU,EAAE,GAAG,EAAE,EAAE;YAC9B,IAAI,GAAG,CAAC,SAAS,EAAE;gBACjB,OAAO;aACR;YACD,IAAI,GAAG,CAAC,WAAW,EAAE;gBACnB,GAAG,CAAC,GAAG,EAAE,CAAC;gBACV,OAAO;aACR;YAED,GAAG,CAAC,UAAU,GAAG,kBAAU,CAAC,WAAW,CAAC;YACxC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACxB,CAAC,CAAC;QAQA,IAAI,YAAK,CAAC,YAAY,CAAC,kBAAkB,CAAC,EAAE;YAC1C,IAAI,CAAC,MAAM,GAAG,IAAI,iBAAQ,EAAE,CAAC;YAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvB,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,kBAAkB,CAAC,MAAM,CAAC;SACnD;aAAM,IAAI,kBAAkB,CAAC,IAAI,IAAI,IAAA,yBAAU,EAAC,kBAAkB,CAAC,IAAI,CAAC,EAAE;YACzE,IAAI,CAAC,MAAM,GAAG,kBAAkB,CAAC;SAClC;IACH,CAAC;IAED,SAAS;QACP,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED,UAAU;QACR,MAAM,EACJ,IAAI,GAAG,0BAA0B,EACjC,WAAW,GAAG,SAAS,EACvB,MAAM,GAAG,SAAS,GACnB,GAAG,IAAI,CAAC,OAAO,CAAC;QACjB,OAAO;YACL,IAAI;YACJ,WAAW;YACX,MAAM;SACP,CAAC;IACJ,CAAC;IAED,IAAI,YAAY;QAId,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,eAAe,CACb,OAAkE;QAElE,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC;QAC3B,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAjED,wCAiEC","sourcesContent":["import { Readable } from 'stream';\r\nimport { types } from 'util';\r\nimport { HttpStatus } from '../enums';\r\nimport { isFunction } from '../utils/shared.utils';\r\nimport { StreamableFileOptions, StreamableHandlerResponse } from './interfaces';\r\n\r\n/**\r\n * @see [Streaming files](https://docs.nestjs.com/techniques/streaming-files)\r\n *\r\n * @publicApi\r\n */\r\nexport class StreamableFile {\r\n  private readonly stream: Readable;\r\n\r\n  protected handleError: (\r\n    err: Error,\r\n    response: StreamableHandlerResponse,\r\n  ) => void = (err: Error, res) => {\r\n    if (res.destroyed) {\r\n      return;\r\n    }\r\n    if (res.headersSent) {\r\n      res.end();\r\n      return;\r\n    }\r\n\r\n    res.statusCode = HttpStatus.BAD_REQUEST;\r\n    res.send(err.message);\r\n  };\r\n\r\n  constructor(buffer: Uint8Array, options?: StreamableFileOptions);\r\n  constructor(readable: Readable, options?: StreamableFileOptions);\r\n  constructor(\r\n    bufferOrReadStream: Uint8Array | Readable,\r\n    readonly options: StreamableFileOptions = {},\r\n  ) {\r\n    if (types.isUint8Array(bufferOrReadStream)) {\r\n      this.stream = new Readable();\r\n      this.stream.push(bufferOrReadStream);\r\n      this.stream.push(null);\r\n      this.options.length ??= bufferOrReadStream.length;\r\n    } else if (bufferOrReadStream.pipe && isFunction(bufferOrReadStream.pipe)) {\r\n      this.stream = bufferOrReadStream;\r\n    }\r\n  }\r\n\r\n  getStream(): Readable {\r\n    return this.stream;\r\n  }\r\n\r\n  getHeaders() {\r\n    const {\r\n      type = 'application/octet-stream',\r\n      disposition = undefined,\r\n      length = undefined,\r\n    } = this.options;\r\n    return {\r\n      type,\r\n      disposition,\r\n      length,\r\n    };\r\n  }\r\n\r\n  get errorHandler(): (\r\n    err: Error,\r\n    response: StreamableHandlerResponse,\r\n  ) => void {\r\n    return this.handleError;\r\n  }\r\n\r\n  setErrorHandler(\r\n    handler: (err: Error, response: StreamableHandlerResponse) => void,\r\n  ) {\r\n    this.handleError = handler;\r\n    return this;\r\n  }\r\n}\r\n"]}